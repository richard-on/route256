
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>domain: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/domain/addtocart.go (100.0%)</option>
				
				<option value="file1">gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/domain/deletefromcart.go (100.0%)</option>
				
				<option value="file2">gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/domain/domain.go (90.9%)</option>
				
				<option value="file3">gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/domain/listcart.go (100.0%)</option>
				
				<option value="file4">gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/domain/purchase.go (100.0%)</option>
				
				<option value="file5">gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/domain/cancelorder.go (81.2%)</option>
				
				<option value="file6">gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/domain/createorder.go (92.5%)</option>
				
				<option value="file7">gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/domain/domain.go (87.5%)</option>
				
				<option value="file8">gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/domain/listorder.go (100.0%)</option>
				
				<option value="file9">gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/domain/orderpaid.go (100.0%)</option>
				
				<option value="file10">gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/domain/stocks.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package domain

import (
        "context"

        "github.com/pkg/errors"
        "gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/model"
)

var (
        // ErrInsufficientStocks is the error returned when current stock for an item is not enough to fulfill the order.
        ErrInsufficientStocks = errors.New("insufficient stock")
)

// AddToCart adds a number of items with given sku to user's cart.
func (d *Domain) AddToCart(ctx context.Context, user int64, item model.Item) error <span class="cov8" title="1">{
        stocks, err := d.StockChecker.Stocks(ctx, item.SKU)
        if err != nil </span><span class="cov8" title="1">{
                return errors.WithMessage(err, "checking stock")
        }</span>

        <span class="cov8" title="1">count, err := d.CheckoutRepo.GetItemCartCount(ctx, user, item)
        if err != nil &amp;&amp; !errors.Is(err, ErrNotInCart) </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">inStock := false
        counter := int64(item.Count) + int64(count)
        for _, stock := range stocks </span><span class="cov8" title="1">{
                counter -= int64(stock.Count)
                if counter &lt;= 0 </span><span class="cov8" title="1">{
                        inStock = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !inStock </span><span class="cov8" title="1">{
                return ErrInsufficientStocks
        }</span>

        <span class="cov8" title="1">err = d.CheckoutRepo.AddToCart(ctx, user, item)

        return err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package domain

import (
        "context"

        "github.com/pkg/errors"
        "gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/model"
)

var (
        // ErrNotInCart is the error returned when provided item is not found in user's cart.
        ErrNotInCart = errors.New("this item is not in cart")
        // ErrNotEnoughInCart is the error returned when cart count for this item is less than was requested to delete.
        ErrNotEnoughInCart = errors.New("cart count for this item is less than in delete request")
)

// DeleteFromCart deletes a number of items with given sku from user's cart.
func (d *Domain) DeleteFromCart(ctx context.Context, user int64, item model.Item) error <span class="cov8" title="1">{

        // Start transaction that reads cart count for this item and then decreases it or removes item for the database.
        err := d.Transactor.RunReadCommitted(ctx, func(ctxTX context.Context) error </span><span class="cov8" title="1">{
                count, err := d.CheckoutRepo.GetItemCartCount(ctxTX, user, item)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">switch </span>{
                case count == int32(item.Count):<span class="cov8" title="1">
                        // If no items should be left in the cart after delete operation, delete the record entirely.
                        if err = d.CheckoutRepo.DeleteItemCart(ctxTX, user, item.SKU); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                case count &gt; int32(item.Count):<span class="cov8" title="1">
                        // Otherwise, decrease count for this item
                        if err = d.CheckoutRepo.DecreaseItemCartCount(ctxTX, user, item); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                case count &lt; int32(item.Count):<span class="cov8" title="1">
                        return errors.WithMessagef(ErrNotEnoughInCart, "item %v", item.SKU)</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package domain

//go:generate minimock -i StockChecker -o ./mocks/ -s "_minimock.go"
//go:generate minimock -i ProductLister -o ./mocks/ -s "_minimock.go"
//go:generate minimock -i OrderCreator -o ./mocks/ -s "_minimock.go"
//go:generate minimock -i github.com/jackc/pgx/v4.Tx -o ./mocks/tx_minimock.go -n TxMock
//go:generate minimock -i CheckoutRepo -o ./mocks/ -s "_minimock.go"

import (
        "context"

        "gitlab.ozon.dev/rragusskiy/homework-1/checkout/config"
        "gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/model"
)

// StockChecker is the interface used for obtaining Stock of a product in all warehouses.
type StockChecker interface {
        Stocks(ctx context.Context, sku uint32) ([]*model.Stock, error)
}

// ProductLister is the interface used for obtaining ProductInfo.
type ProductLister interface {
        GetProduct(ctx context.Context, sku uint32) (model.ProductInfo, error)
}

// OrderCreator is the interface used for order creation and obtaining Order Info.
type OrderCreator interface {
        CreateOrder(ctx context.Context, user int64, items []model.Item) (int64, error)
}

// Transactor is the interface that provides abstraction for different transaction isolation levels.
type Transactor interface {

        // RunReadCommitted runs DB operations provided to it as a transaction with read committed isolation level.
        //
        // Note: You should always use ctxTX Context inside transaction block.
        // Do not use the context passed as the first parameter.
        RunReadCommitted(ctx context.Context, f func(ctxTX context.Context) error) error

        // RunRepeatableRead runs DB operations provided to it as a transaction with repeatable read isolation level.
        //
        // Note: You should always use ctxTX Context inside transaction block.
        // Do not use the context passed as the first parameter.
        RunRepeatableRead(ctx context.Context, f func(ctxTX context.Context) error) error

        // RunSerializable runs DB operations provided to it as a transaction with serializable isolation level.
        //
        // Note: You should always use ctxTX Context inside transaction block.
        // Do not use the context passed as the first parameter.
        RunSerializable(ctx context.Context, f func(ctxTX context.Context) error) error
}

type CheckoutRepo interface {
        AddToCart(ctx context.Context, userID int64, modelItem model.Item) error

        GetItemCartCount(ctx context.Context, userID int64, modelItem model.Item) (int32, error)
        DecreaseItemCartCount(ctx context.Context, userID int64, modelItem model.Item) error
        DeleteItemCart(ctx context.Context, userID int64, sku uint32) error
        ClearCart(ctx context.Context, userID int64) error

        GetCartItems(ctx context.Context, userID int64) ([]model.Item, error)
}

// Domain represents business logic of checkout service. It wraps interfaces used in a service.
type Domain struct {
        config config.Service
        CheckoutRepo
        Transactor
        StockChecker
        ProductLister
        OrderCreator
}

// New creates a new Domain.
func New(config config.Service, repo CheckoutRepo, transactor Transactor,
        checker StockChecker, lister ProductLister, creator OrderCreator) *Domain <span class="cov0" title="0">{
        return &amp;Domain{
                config,
                repo,
                transactor,
                checker,
                lister,
                creator,
        }
}</span>

// NewMockDomain creates a new mock Domain used for testing.
func NewMockDomain(opts ...any) *Domain <span class="cov8" title="1">{
        d := Domain{}

        for _, v := range opts </span><span class="cov8" title="1">{
                switch s := v.(type) </span>{
                case config.Service:<span class="cov8" title="1">
                        d.config = s</span>
                case CheckoutRepo:<span class="cov8" title="1">
                        d.CheckoutRepo = s</span>
                case Transactor:<span class="cov8" title="1">
                        d.Transactor = s</span>
                case StockChecker:<span class="cov8" title="1">
                        d.StockChecker = s</span>
                case ProductLister:<span class="cov8" title="1">
                        d.ProductLister = s</span>
                case OrderCreator:<span class="cov8" title="1">
                        d.OrderCreator = s</span>
                }
        }

        <span class="cov8" title="1">return &amp;d</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package domain

import (
        "context"

        "github.com/pkg/errors"
        "gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/model"
        "gitlab.ozon.dev/rragusskiy/homework-1/lib/workerpool"
)

var (
        ErrEmptyCart = errors.New("cart is empty")
)

// ListCart lists all products that are currently in a user's cart.
func (d *Domain) ListCart(ctx context.Context, user int64) ([]model.Item, uint32, error) <span class="cov8" title="1">{
        items, err := d.CheckoutRepo.GetCartItems(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">wp := workerpool.New[model.Item, model.Item](ctx, d.config.MaxPoolWorkers)

        wp.SubmitMany(func(ctx context.Context, item model.Item) (model.Item, error) </span><span class="cov8" title="1">{
                product, err := d.ProductLister.GetProduct(ctx, item.SKU)
                if err != nil </span><span class="cov8" title="1">{
                        // Even a single error will render the result unusable,
                        // so cancel context and stop worker pool as soon as possible.
                        wp.StopNow()
                        return model.Item{}, err
                }</span>

                <span class="cov8" title="1">item.ProductInfo = model.ProductInfo{
                        Name:  product.Name,
                        Price: product.Price,
                }

                return item, nil</span>

        }, items)

        <span class="cov8" title="1">wp.Wait()

        var totalPrice uint32 = 0
        for i, res := range wp.GetResult() </span><span class="cov8" title="1">{
                if res.Err != nil </span><span class="cov8" title="1">{
                        return nil, 0, res.Err
                }</span>
                <span class="cov8" title="1">items[i] = res.Value
                totalPrice += items[i].ProductInfo.Price * uint32(items[i].Count)</span>
        }

        <span class="cov8" title="1">return items, totalPrice, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package domain

import (
        "context"
)

// CreateOrder creates a new order for a user reserving ordered products in a warehouse.
func (d *Domain) CreateOrder(ctx context.Context, user int64) (int64, error) <span class="cov8" title="1">{

        items, err := d.CheckoutRepo.GetCartItems(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">orderInfo, err := d.OrderCreator.CreateOrder(ctx, user, items)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = d.CheckoutRepo.ClearCart(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return orderInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package domain

import (
        "context"
        "fmt"
        "time"

        "github.com/pkg/errors"
        "gitlab.ozon.dev/rragusskiy/homework-1/lib/workerpool"
)

var (
        ErrOrderCancelled = errors.New("order does not exist or has already been cancelled")
        ErrStockNotExists = errors.New("warehouse or sku does not exist")
)

// CancelOrder cancels order, makes previously reserved products available.
func (d *Domain) CancelOrder(ctx context.Context, orderID int64) error <span class="cov8" title="1">{
        err := d.Transactor.RunRepeatableRead(ctx, func(ctxTX context.Context) error </span><span class="cov8" title="1">{
                err := d.LOMSRepo.CancelOrder(ctxTX, orderID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">skus, stocks, err := d.LOMSRepo.RemoveItemsFromReserved(ctxTX, orderID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">wp := workerpool.New[int64, struct{}](ctx, d.config.MaxPoolWorkers)

                for i, sku := range skus </span><span class="cov8" title="1">{
                        i := i
                        wp.SubmitOne(func(ctx context.Context, sku int64) (struct{}, error) </span><span class="cov8" title="1">{
                                err = d.LOMSRepo.IncreaseStock(ctxTX, sku, stocks[i])
                                if err != nil </span><span class="cov8" title="1">{
                                        wp.StopNow()
                                        return struct{}{}, err
                                }</span>
                                <span class="cov8" title="1">return struct{}{}, nil</span>
                        }, sku)
                }

                <span class="cov8" title="1">wp.Wait()

                for _, res := range wp.GetResult() </span><span class="cov8" title="1">{
                        if res.Err != nil </span><span class="cov8" title="1">{
                                return res.Err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CancelUnpaidOrders cancels orders that are awaiting payment (status model.AwaitingPayment)
// for more than given paymentTimeout.
func (d *Domain) CancelUnpaidOrders(ctx context.Context, paymentTimeout time.Duration) []error <span class="cov8" title="1">{
        unpaidOrders, err := d.LOMSRepo.ListUnpaidOrders(ctx, paymentTimeout)
        if err != nil </span><span class="cov8" title="1">{
                return []error{err}
        }</span>

        <span class="cov8" title="1">wp := workerpool.New[int64, struct{}](ctx, d.config.MaxPoolWorkers)

        wp.SubmitMany(func(ctx context.Context, id int64) (struct{}, error) </span><span class="cov8" title="1">{
                err = d.CancelOrder(ctx, id)
                if err != nil </span><span class="cov8" title="1">{
                        // Error while cancelling one order must not affect cancelling all other orders,
                        // so just write err in a channel and try to cancel other orders.
                        return struct{}{}, fmt.Errorf("cancelling order %v: %w", id, err)
                }</span>

                <span class="cov8" title="1">return struct{}{}, nil</span>
        }, unpaidOrders)

        <span class="cov8" title="1">wp.Wait()

        var cancelErrors []error
        for _, res := range wp.GetResult() </span><span class="cov8" title="1">{
                if res.Err != nil </span><span class="cov8" title="1">{
                        cancelErrors = append(cancelErrors, err)
                }</span>
        }

        <span class="cov8" title="1">return cancelErrors</span>
}

// MonitorUnpaid monitors unpaid orders at a given rate.
func (d *Domain) MonitorUnpaid(ctx context.Context, errChan chan error) <span class="cov0" title="0">{
        ticker := time.NewTicker(d.config.CancelInterval)
        // Start a separate goroutine to check and cancel unpaid orders.
        for </span><span class="cov0" title="0">{
                select </span>{
                // Run cancelling on each tick.
                case &lt;-ticker.C:<span class="cov0" title="0">
                        errSlice := d.CancelUnpaidOrders(ctx, d.config.PaymentTimeout)
                        if len(errSlice) &gt; 0 </span><span class="cov0" title="0">{
                                for _, cancelErr := range errSlice </span><span class="cov0" title="0">{
                                        errChan &lt;- cancelErr
                                }</span>
                        }
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        close(errChan)
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package domain

import (
        "context"
        "fmt"

        "github.com/pkg/errors"
        "gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/model"
)

// CreateOrder creates a new order for a user, reserves ordered products in a warehouse.
func (d *Domain) CreateOrder(ctx context.Context, user int64, items []model.Item) (int64, error) <span class="cov8" title="1">{

        var orderID int64
        // This transaction inserts order info to database. After this step, the order is created.
        err := d.Transactor.RunReadCommitted(ctx, func(ctxTX context.Context) (err error) </span><span class="cov8" title="1">{
                orderID, err = d.LOMSRepo.InsertOrderInfo(ctxTX, model.Order{
                        Status: model.NewOrder,
                        User:   user,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">err = d.LOMSRepo.InsertOrderItems(ctxTX, orderID, items)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        // After order creation, this transaction checks whether we have enough items in stock to fulfill the order.
        // If it is fine, we pass ordered number of items into reserves.
        <span class="cov8" title="1">err = d.Transactor.RunRepeatableRead(ctx, func(ctxTX context.Context) (err error) </span><span class="cov8" title="1">{
                var stocks []model.Stock
                for _, item := range items </span><span class="cov8" title="1">{
                        stocks, err = d.LOMSRepo.GetStocks(ctxTX, item.SKU)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">toReserve := uint64(item.Count)
                        for _, stock := range stocks </span><span class="cov8" title="1">{
                                if toReserve &lt; stock.Count </span><span class="cov0" title="0">{
                                        stock.Count = toReserve
                                }</span>
                                <span class="cov8" title="1">toReserve -= stock.Count

                                if err = d.LOMSRepo.DecreaseStock(ctxTX, int64(item.SKU), stock); err != nil </span><span class="cov8" title="1">{
                                        return errors.WithMessagef(err, "counting item with sku %v", item.SKU)
                                }</span>

                                <span class="cov8" title="1">if err = d.LOMSRepo.ReserveItem(ctxTX, orderID, int64(item.SKU), stock); err != nil </span><span class="cov8" title="1">{
                                        return errors.WithMessagef(err, "reserving item with sku %v", item.SKU)
                                }</span>

                                <span class="cov8" title="1">if toReserve == 0 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">if toReserve &gt; 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("order %v: sku %v: request %v items: not enough in stock",
                                        orderID, item.SKU, item.Count)
                        }</span>
                }

                // If we have successfully reserved items, change order status to "awaiting payment".
                <span class="cov8" title="1">err = d.LOMSRepo.ChangeOrderStatus(ctxTX, orderID, model.AwaitingPayment)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // If we were not able to secure items, change order status to "failed".
                changeErr := d.LOMSRepo.ChangeOrderStatus(ctx, orderID, model.Failed)
                if changeErr != nil </span><span class="cov8" title="1">{
                        return 0, changeErr
                }</span>

                <span class="cov8" title="1">return 0, err</span>
        }

        <span class="cov8" title="1">return orderID, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package domain provides business-logic for Logistics and Order Management System.
package domain

//go:generate minimock -i github.com/jackc/pgx/v4.Tx -o ./mocks/tx_minimock.go -n TxMock
//go:generate minimock -i LOMSRepo -o ./mocks/ -s "_minimock.go"

import (
        "context"
        "time"

        "gitlab.ozon.dev/rragusskiy/homework-1/loms/config"
        "gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/model"
)

// Transactor is the interface that provides abstraction for different transaction isolation levels.
type Transactor interface {

        // RunReadCommitted runs DB operations provided to it as a transaction with read committed isolation level.
        //
        // Note: You should always use ctxTX Context inside transaction block.
        // Do not use the context passed as the first parameter.
        RunReadCommitted(ctx context.Context, f func(ctxTX context.Context) error) error

        // RunRepeatableRead runs DB operations provided to it as a transaction with repeatable read isolation level.
        //
        // Note: You should always use ctxTX Context inside transaction block.
        // Do not use the context passed as the first parameter.
        RunRepeatableRead(ctx context.Context, f func(ctxTX context.Context) error) error

        // RunSerializable runs DB operations provided to it as a transaction with serializable isolation level.
        //
        // Note: You should always use ctxTX Context inside transaction block.
        // Do not use the context passed as the first parameter.
        RunSerializable(ctx context.Context, f func(ctxTX context.Context) error) error
}

// LOMSRepo is the interface that provides methods used in LOMS Repository layer.
type LOMSRepo interface {
        InsertOrderInfo(ctx context.Context, order model.Order) (int64, error)
        InsertOrderItems(ctx context.Context, orderID int64, domainItems []model.Item) error

        ListOrderInfo(ctx context.Context, orderID int64) (model.Order, error)
        ListOrderItems(ctx context.Context, orderID int64) ([]model.Item, error)
        ListUnpaidOrders(ctx context.Context, paymentWait time.Duration) ([]int64, error)

        CancelOrder(ctx context.Context, orderID int64) error
        PayOrder(ctx context.Context, orderID int64) error
        ChangeOrderStatus(ctx context.Context, orderID int64, status model.Status) error

        GetStocks(ctx context.Context, sku uint32) ([]model.Stock, error)
        DecreaseStock(ctx context.Context, sku int64, stock model.Stock) error
        IncreaseStock(ctx context.Context, sku int64, stock model.Stock) error

        ReserveItem(ctx context.Context, orderID int64, sku int64, stock model.Stock) error
        RemoveItemsFromReserved(ctx context.Context, orderID int64) ([]int64, []model.Stock, error)
}

// Domain represents business logic of Logistics and Order Management System.
// It should wrap interfaces used in a service.
type Domain struct {
        config config.Service
        LOMSRepo
        Transactor
}

// New creates a new Domain.
func New(config config.Service, repo LOMSRepo, tx Transactor) *Domain <span class="cov0" title="0">{
        return &amp;Domain{
                config,
                repo,
                tx,
        }
}</span>

// NewMockDomain creates a new mock Domain used for testing.
func NewMockDomain(opts ...any) *Domain <span class="cov8" title="1">{
        d := Domain{}

        for _, v := range opts </span><span class="cov8" title="1">{
                switch s := v.(type) </span>{
                case config.Service:<span class="cov8" title="1">
                        d.config = s</span>
                case LOMSRepo:<span class="cov8" title="1">
                        d.LOMSRepo = s</span>
                case Transactor:<span class="cov8" title="1">
                        d.Transactor = s</span>
                }
        }

        <span class="cov8" title="1">return &amp;d</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package domain

import (
        "context"

        "github.com/pkg/errors"
        "gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/model"
)

var (
        ErrEmptyOrder   = errors.New("order does not exist")
        ErrNoOrderItems = errors.New("order does not contain any items")
)

// ListOrder lists OrderInfo for a given orderID.
func (d *Domain) ListOrder(ctx context.Context, orderID int64) (model.Order, error) <span class="cov8" title="1">{

        var orderInfo model.Order
        err := d.Transactor.RunReadCommitted(ctx, func(ctxTX context.Context) (err error) </span><span class="cov8" title="1">{

                orderInfo, err = d.LOMSRepo.ListOrderInfo(ctxTX, orderID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">orderInfo.Items, err = d.LOMSRepo.ListOrderItems(ctxTX, orderID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return model.Order{}, err
        }</span>

        <span class="cov8" title="1">return orderInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package domain

import "context"

// OrderPaid marks order as paid.
func (d *Domain) OrderPaid(ctx context.Context, orderID int64) error <span class="cov8" title="1">{

        // This transaction ensures that if order is paid, items are removed from reserve.
        err := d.Transactor.RunReadCommitted(ctx, func(ctxTX context.Context) (err error) </span><span class="cov8" title="1">{

                err = d.LOMSRepo.PayOrder(ctxTX, orderID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">_, _, err = d.LOMSRepo.RemoveItemsFromReserved(ctxTX, orderID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package domain

import (
        "context"

        "gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/model"
)

// Stocks returns a number of available products with a given SKU in different warehouses.
func (d *Domain) Stocks(ctx context.Context, sku uint32) ([]model.Stock, error) <span class="cov8" title="1">{

        stocks, err := d.LOMSRepo.GetStocks(ctx, sku)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stocks, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
