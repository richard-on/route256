package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/repository/transactor.Conn -o ./mocks\conn_minimock.go -n ConnMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
)

// ConnMock implements transactor.Conn
type ConnMock struct {
	t minimock.Tester

	funcBegin          func(ctx context.Context) (t1 pgx.Tx, err error)
	inspectFuncBegin   func(ctx context.Context)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mConnMockBegin

	funcBeginTx          func(ctx context.Context, t1 pgx.TxOptions) (t2 pgx.Tx, err error)
	inspectFuncBeginTx   func(ctx context.Context, t1 pgx.TxOptions)
	afterBeginTxCounter  uint64
	beforeBeginTxCounter uint64
	BeginTxMock          mConnMockBeginTx

	funcExec          func(ctx context.Context, sql string, arguments ...interface{}) (c2 pgconn.CommandTag, err error)
	inspectFuncExec   func(ctx context.Context, sql string, arguments ...interface{})
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mConnMockExec

	funcQuery          func(ctx context.Context, query string, args ...any) (r1 pgx.Rows, err error)
	inspectFuncQuery   func(ctx context.Context, query string, args ...any)
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mConnMockQuery
}

// NewConnMock returns a mock for transactor.Conn
func NewConnMock(t minimock.Tester) *ConnMock {
	m := &ConnMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mConnMockBegin{mock: m}
	m.BeginMock.callArgs = []*ConnMockBeginParams{}

	m.BeginTxMock = mConnMockBeginTx{mock: m}
	m.BeginTxMock.callArgs = []*ConnMockBeginTxParams{}

	m.ExecMock = mConnMockExec{mock: m}
	m.ExecMock.callArgs = []*ConnMockExecParams{}

	m.QueryMock = mConnMockQuery{mock: m}
	m.QueryMock.callArgs = []*ConnMockQueryParams{}

	return m
}

type mConnMockBegin struct {
	mock               *ConnMock
	defaultExpectation *ConnMockBeginExpectation
	expectations       []*ConnMockBeginExpectation

	callArgs []*ConnMockBeginParams
	mutex    sync.RWMutex
}

// ConnMockBeginExpectation specifies expectation struct of the Conn.Begin
type ConnMockBeginExpectation struct {
	mock    *ConnMock
	params  *ConnMockBeginParams
	results *ConnMockBeginResults
	Counter uint64
}

// ConnMockBeginParams contains parameters of the Conn.Begin
type ConnMockBeginParams struct {
	ctx context.Context
}

// ConnMockBeginResults contains results of the Conn.Begin
type ConnMockBeginResults struct {
	t1  pgx.Tx
	err error
}

// Expect sets up expected params for Conn.Begin
func (mmBegin *mConnMockBegin) Expect(ctx context.Context) *mConnMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("ConnMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &ConnMockBeginExpectation{}
	}

	mmBegin.defaultExpectation.params = &ConnMockBeginParams{ctx}
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the Conn.Begin
func (mmBegin *mConnMockBegin) Inspect(f func(ctx context.Context)) *mConnMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for ConnMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by Conn.Begin
func (mmBegin *mConnMockBegin) Return(t1 pgx.Tx, err error) *ConnMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("ConnMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &ConnMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &ConnMockBeginResults{t1, err}
	return mmBegin.mock
}

// Set uses given function f to mock the Conn.Begin method
func (mmBegin *mConnMockBegin) Set(f func(ctx context.Context) (t1 pgx.Tx, err error)) *ConnMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the Conn.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the Conn.Begin method")
	}

	mmBegin.mock.funcBegin = f
	return mmBegin.mock
}

// When sets expectation for the Conn.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mConnMockBegin) When(ctx context.Context) *ConnMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("ConnMock.Begin mock is already set by Set")
	}

	expectation := &ConnMockBeginExpectation{
		mock:   mmBegin.mock,
		params: &ConnMockBeginParams{ctx},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up Conn.Begin return parameters for the expectation previously defined by the When method
func (e *ConnMockBeginExpectation) Then(t1 pgx.Tx, err error) *ConnMock {
	e.results = &ConnMockBeginResults{t1, err}
	return e.mock
}

// Begin implements transactor.Conn
func (mmBegin *ConnMock) Begin(ctx context.Context) (t1 pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx)
	}

	mm_params := &ConnMockBeginParams{ctx}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, mm_params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		mm_want := mmBegin.BeginMock.defaultExpectation.params
		mm_got := ConnMockBeginParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBegin.t.Errorf("ConnMock.Begin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the ConnMock.Begin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx)
	}
	mmBegin.t.Fatalf("Unexpected call to ConnMock.Begin. %v", ctx)
	return
}

// BeginAfterCounter returns a count of finished ConnMock.Begin invocations
func (mmBegin *ConnMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of ConnMock.Begin invocations
func (mmBegin *ConnMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mConnMockBegin) Calls() []*ConnMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*ConnMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockBeginDone() bool {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginInspect logs each unmet expectation
func (m *ConnMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.Begin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConnMock.Begin")
		} else {
			m.t.Errorf("Expected call to ConnMock.Begin with params: %#v", *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		m.t.Error("Expected call to ConnMock.Begin")
	}
}

type mConnMockBeginTx struct {
	mock               *ConnMock
	defaultExpectation *ConnMockBeginTxExpectation
	expectations       []*ConnMockBeginTxExpectation

	callArgs []*ConnMockBeginTxParams
	mutex    sync.RWMutex
}

// ConnMockBeginTxExpectation specifies expectation struct of the Conn.BeginTx
type ConnMockBeginTxExpectation struct {
	mock    *ConnMock
	params  *ConnMockBeginTxParams
	results *ConnMockBeginTxResults
	Counter uint64
}

// ConnMockBeginTxParams contains parameters of the Conn.BeginTx
type ConnMockBeginTxParams struct {
	ctx context.Context
	t1  pgx.TxOptions
}

// ConnMockBeginTxResults contains results of the Conn.BeginTx
type ConnMockBeginTxResults struct {
	t2  pgx.Tx
	err error
}

// Expect sets up expected params for Conn.BeginTx
func (mmBeginTx *mConnMockBeginTx) Expect(ctx context.Context, t1 pgx.TxOptions) *mConnMockBeginTx {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("ConnMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &ConnMockBeginTxExpectation{}
	}

	mmBeginTx.defaultExpectation.params = &ConnMockBeginTxParams{ctx, t1}
	for _, e := range mmBeginTx.expectations {
		if minimock.Equal(e.params, mmBeginTx.defaultExpectation.params) {
			mmBeginTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeginTx.defaultExpectation.params)
		}
	}

	return mmBeginTx
}

// Inspect accepts an inspector function that has same arguments as the Conn.BeginTx
func (mmBeginTx *mConnMockBeginTx) Inspect(f func(ctx context.Context, t1 pgx.TxOptions)) *mConnMockBeginTx {
	if mmBeginTx.mock.inspectFuncBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("Inspect function is already set for ConnMock.BeginTx")
	}

	mmBeginTx.mock.inspectFuncBeginTx = f

	return mmBeginTx
}

// Return sets up results that will be returned by Conn.BeginTx
func (mmBeginTx *mConnMockBeginTx) Return(t2 pgx.Tx, err error) *ConnMock {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("ConnMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &ConnMockBeginTxExpectation{mock: mmBeginTx.mock}
	}
	mmBeginTx.defaultExpectation.results = &ConnMockBeginTxResults{t2, err}
	return mmBeginTx.mock
}

// Set uses given function f to mock the Conn.BeginTx method
func (mmBeginTx *mConnMockBeginTx) Set(f func(ctx context.Context, t1 pgx.TxOptions) (t2 pgx.Tx, err error)) *ConnMock {
	if mmBeginTx.defaultExpectation != nil {
		mmBeginTx.mock.t.Fatalf("Default expectation is already set for the Conn.BeginTx method")
	}

	if len(mmBeginTx.expectations) > 0 {
		mmBeginTx.mock.t.Fatalf("Some expectations are already set for the Conn.BeginTx method")
	}

	mmBeginTx.mock.funcBeginTx = f
	return mmBeginTx.mock
}

// When sets expectation for the Conn.BeginTx which will trigger the result defined by the following
// Then helper
func (mmBeginTx *mConnMockBeginTx) When(ctx context.Context, t1 pgx.TxOptions) *ConnMockBeginTxExpectation {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("ConnMock.BeginTx mock is already set by Set")
	}

	expectation := &ConnMockBeginTxExpectation{
		mock:   mmBeginTx.mock,
		params: &ConnMockBeginTxParams{ctx, t1},
	}
	mmBeginTx.expectations = append(mmBeginTx.expectations, expectation)
	return expectation
}

// Then sets up Conn.BeginTx return parameters for the expectation previously defined by the When method
func (e *ConnMockBeginTxExpectation) Then(t2 pgx.Tx, err error) *ConnMock {
	e.results = &ConnMockBeginTxResults{t2, err}
	return e.mock
}

// BeginTx implements transactor.Conn
func (mmBeginTx *ConnMock) BeginTx(ctx context.Context, t1 pgx.TxOptions) (t2 pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBeginTx.beforeBeginTxCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginTx.afterBeginTxCounter, 1)

	if mmBeginTx.inspectFuncBeginTx != nil {
		mmBeginTx.inspectFuncBeginTx(ctx, t1)
	}

	mm_params := &ConnMockBeginTxParams{ctx, t1}

	// Record call args
	mmBeginTx.BeginTxMock.mutex.Lock()
	mmBeginTx.BeginTxMock.callArgs = append(mmBeginTx.BeginTxMock.callArgs, mm_params)
	mmBeginTx.BeginTxMock.mutex.Unlock()

	for _, e := range mmBeginTx.BeginTxMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t2, e.results.err
		}
	}

	if mmBeginTx.BeginTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginTx.BeginTxMock.defaultExpectation.Counter, 1)
		mm_want := mmBeginTx.BeginTxMock.defaultExpectation.params
		mm_got := ConnMockBeginTxParams{ctx, t1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBeginTx.t.Errorf("ConnMock.BeginTx got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBeginTx.BeginTxMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginTx.t.Fatal("No results are set for the ConnMock.BeginTx")
		}
		return (*mm_results).t2, (*mm_results).err
	}
	if mmBeginTx.funcBeginTx != nil {
		return mmBeginTx.funcBeginTx(ctx, t1)
	}
	mmBeginTx.t.Fatalf("Unexpected call to ConnMock.BeginTx. %v %v", ctx, t1)
	return
}

// BeginTxAfterCounter returns a count of finished ConnMock.BeginTx invocations
func (mmBeginTx *ConnMock) BeginTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTx.afterBeginTxCounter)
}

// BeginTxBeforeCounter returns a count of ConnMock.BeginTx invocations
func (mmBeginTx *ConnMock) BeginTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTx.beforeBeginTxCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.BeginTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeginTx *mConnMockBeginTx) Calls() []*ConnMockBeginTxParams {
	mmBeginTx.mutex.RLock()

	argCopy := make([]*ConnMockBeginTxParams, len(mmBeginTx.callArgs))
	copy(argCopy, mmBeginTx.callArgs)

	mmBeginTx.mutex.RUnlock()

	return argCopy
}

// MinimockBeginTxDone returns true if the count of the BeginTx invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockBeginTxDone() bool {
	for _, e := range m.BeginTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTx != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginTxInspect logs each unmet expectation
func (m *ConnMock) MinimockBeginTxInspect() {
	for _, e := range m.BeginTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.BeginTx with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		if m.BeginTxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConnMock.BeginTx")
		} else {
			m.t.Errorf("Expected call to ConnMock.BeginTx with params: %#v", *m.BeginTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTx != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		m.t.Error("Expected call to ConnMock.BeginTx")
	}
}

type mConnMockExec struct {
	mock               *ConnMock
	defaultExpectation *ConnMockExecExpectation
	expectations       []*ConnMockExecExpectation

	callArgs []*ConnMockExecParams
	mutex    sync.RWMutex
}

// ConnMockExecExpectation specifies expectation struct of the Conn.Exec
type ConnMockExecExpectation struct {
	mock    *ConnMock
	params  *ConnMockExecParams
	results *ConnMockExecResults
	Counter uint64
}

// ConnMockExecParams contains parameters of the Conn.Exec
type ConnMockExecParams struct {
	ctx       context.Context
	sql       string
	arguments []interface{}
}

// ConnMockExecResults contains results of the Conn.Exec
type ConnMockExecResults struct {
	c2  pgconn.CommandTag
	err error
}

// Expect sets up expected params for Conn.Exec
func (mmExec *mConnMockExec) Expect(ctx context.Context, sql string, arguments ...interface{}) *mConnMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("ConnMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &ConnMockExecExpectation{}
	}

	mmExec.defaultExpectation.params = &ConnMockExecParams{ctx, sql, arguments}
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the Conn.Exec
func (mmExec *mConnMockExec) Inspect(f func(ctx context.Context, sql string, arguments ...interface{})) *mConnMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for ConnMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by Conn.Exec
func (mmExec *mConnMockExec) Return(c2 pgconn.CommandTag, err error) *ConnMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("ConnMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &ConnMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &ConnMockExecResults{c2, err}
	return mmExec.mock
}

// Set uses given function f to mock the Conn.Exec method
func (mmExec *mConnMockExec) Set(f func(ctx context.Context, sql string, arguments ...interface{}) (c2 pgconn.CommandTag, err error)) *ConnMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the Conn.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the Conn.Exec method")
	}

	mmExec.mock.funcExec = f
	return mmExec.mock
}

// When sets expectation for the Conn.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mConnMockExec) When(ctx context.Context, sql string, arguments ...interface{}) *ConnMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("ConnMock.Exec mock is already set by Set")
	}

	expectation := &ConnMockExecExpectation{
		mock:   mmExec.mock,
		params: &ConnMockExecParams{ctx, sql, arguments},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up Conn.Exec return parameters for the expectation previously defined by the When method
func (e *ConnMockExecExpectation) Then(c2 pgconn.CommandTag, err error) *ConnMock {
	e.results = &ConnMockExecResults{c2, err}
	return e.mock
}

// Exec implements transactor.Conn
func (mmExec *ConnMock) Exec(ctx context.Context, sql string, arguments ...interface{}) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, sql, arguments...)
	}

	mm_params := &ConnMockExecParams{ctx, sql, arguments}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_got := ConnMockExecParams{ctx, sql, arguments}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("ConnMock.Exec got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the ConnMock.Exec")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, sql, arguments...)
	}
	mmExec.t.Fatalf("Unexpected call to ConnMock.Exec. %v %v %v", ctx, sql, arguments)
	return
}

// ExecAfterCounter returns a count of finished ConnMock.Exec invocations
func (mmExec *ConnMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of ConnMock.Exec invocations
func (mmExec *ConnMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mConnMockExec) Calls() []*ConnMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*ConnMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockExecDone() bool {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecInspect logs each unmet expectation
func (m *ConnMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.Exec with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConnMock.Exec")
		} else {
			m.t.Errorf("Expected call to ConnMock.Exec with params: %#v", *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		m.t.Error("Expected call to ConnMock.Exec")
	}
}

type mConnMockQuery struct {
	mock               *ConnMock
	defaultExpectation *ConnMockQueryExpectation
	expectations       []*ConnMockQueryExpectation

	callArgs []*ConnMockQueryParams
	mutex    sync.RWMutex
}

// ConnMockQueryExpectation specifies expectation struct of the Conn.Query
type ConnMockQueryExpectation struct {
	mock    *ConnMock
	params  *ConnMockQueryParams
	results *ConnMockQueryResults
	Counter uint64
}

// ConnMockQueryParams contains parameters of the Conn.Query
type ConnMockQueryParams struct {
	ctx   context.Context
	query string
	args  []any
}

// ConnMockQueryResults contains results of the Conn.Query
type ConnMockQueryResults struct {
	r1  pgx.Rows
	err error
}

// Expect sets up expected params for Conn.Query
func (mmQuery *mConnMockQuery) Expect(ctx context.Context, query string, args ...any) *mConnMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("ConnMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &ConnMockQueryExpectation{}
	}

	mmQuery.defaultExpectation.params = &ConnMockQueryParams{ctx, query, args}
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the Conn.Query
func (mmQuery *mConnMockQuery) Inspect(f func(ctx context.Context, query string, args ...any)) *mConnMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for ConnMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by Conn.Query
func (mmQuery *mConnMockQuery) Return(r1 pgx.Rows, err error) *ConnMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("ConnMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &ConnMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &ConnMockQueryResults{r1, err}
	return mmQuery.mock
}

// Set uses given function f to mock the Conn.Query method
func (mmQuery *mConnMockQuery) Set(f func(ctx context.Context, query string, args ...any) (r1 pgx.Rows, err error)) *ConnMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the Conn.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the Conn.Query method")
	}

	mmQuery.mock.funcQuery = f
	return mmQuery.mock
}

// When sets expectation for the Conn.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mConnMockQuery) When(ctx context.Context, query string, args ...any) *ConnMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("ConnMock.Query mock is already set by Set")
	}

	expectation := &ConnMockQueryExpectation{
		mock:   mmQuery.mock,
		params: &ConnMockQueryParams{ctx, query, args},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up Conn.Query return parameters for the expectation previously defined by the When method
func (e *ConnMockQueryExpectation) Then(r1 pgx.Rows, err error) *ConnMock {
	e.results = &ConnMockQueryResults{r1, err}
	return e.mock
}

// Query implements transactor.Conn
func (mmQuery *ConnMock) Query(ctx context.Context, query string, args ...any) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, query, args...)
	}

	mm_params := &ConnMockQueryParams{ctx, query, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_got := ConnMockQueryParams{ctx, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("ConnMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the ConnMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, query, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to ConnMock.Query. %v %v %v", ctx, query, args)
	return
}

// QueryAfterCounter returns a count of finished ConnMock.Query invocations
func (mmQuery *ConnMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of ConnMock.Query invocations
func (mmQuery *ConnMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mConnMockQuery) Calls() []*ConnMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*ConnMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockQueryDone() bool {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryInspect logs each unmet expectation
func (m *ConnMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.Query with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConnMock.Query")
		} else {
			m.t.Errorf("Expected call to ConnMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		m.t.Error("Expected call to ConnMock.Query")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConnMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeginInspect()

		m.MinimockBeginTxInspect()

		m.MinimockExecInspect()

		m.MinimockQueryInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConnMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConnMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockBeginTxDone() &&
		m.MinimockExecDone() &&
		m.MinimockQueryDone()
}
