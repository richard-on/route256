package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/domain.OutboxRepo -o ./mocks\outbox_repo_minimock.go -n OutboxRepoMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/model/outbox"
)

// OutboxRepoMock implements domain.OutboxRepo
type OutboxRepoMock struct {
	t minimock.Tester

	funcAddMessageWithKey          func(ctx context.Context, key string, payload []byte) (err error)
	inspectFuncAddMessageWithKey   func(ctx context.Context, key string, payload []byte)
	afterAddMessageWithKeyCounter  uint64
	beforeAddMessageWithKeyCounter uint64
	AddMessageWithKeyMock          mOutboxRepoMockAddMessageWithKey

	funcAddMessageWithoutKey          func(ctx context.Context, payload []byte) (err error)
	inspectFuncAddMessageWithoutKey   func(ctx context.Context, payload []byte)
	afterAddMessageWithoutKeyCounter  uint64
	beforeAddMessageWithoutKeyCounter uint64
	AddMessageWithoutKeyMock          mOutboxRepoMockAddMessageWithoutKey

	funcDeleteMessage          func(ctx context.Context, id int64) (err error)
	inspectFuncDeleteMessage   func(ctx context.Context, id int64)
	afterDeleteMessageCounter  uint64
	beforeDeleteMessageCounter uint64
	DeleteMessageMock          mOutboxRepoMockDeleteMessage

	funcListUnsent          func(ctx context.Context) (ma1 []outbox.Message, err error)
	inspectFuncListUnsent   func(ctx context.Context)
	afterListUnsentCounter  uint64
	beforeListUnsentCounter uint64
	ListUnsentMock          mOutboxRepoMockListUnsent

	funcUpdateMessageStatus          func(ctx context.Context, id int64, status outbox.Status) (err error)
	inspectFuncUpdateMessageStatus   func(ctx context.Context, id int64, status outbox.Status)
	afterUpdateMessageStatusCounter  uint64
	beforeUpdateMessageStatusCounter uint64
	UpdateMessageStatusMock          mOutboxRepoMockUpdateMessageStatus
}

// NewOutboxRepoMock returns a mock for domain.OutboxRepo
func NewOutboxRepoMock(t minimock.Tester) *OutboxRepoMock {
	m := &OutboxRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMessageWithKeyMock = mOutboxRepoMockAddMessageWithKey{mock: m}
	m.AddMessageWithKeyMock.callArgs = []*OutboxRepoMockAddMessageWithKeyParams{}

	m.AddMessageWithoutKeyMock = mOutboxRepoMockAddMessageWithoutKey{mock: m}
	m.AddMessageWithoutKeyMock.callArgs = []*OutboxRepoMockAddMessageWithoutKeyParams{}

	m.DeleteMessageMock = mOutboxRepoMockDeleteMessage{mock: m}
	m.DeleteMessageMock.callArgs = []*OutboxRepoMockDeleteMessageParams{}

	m.ListUnsentMock = mOutboxRepoMockListUnsent{mock: m}
	m.ListUnsentMock.callArgs = []*OutboxRepoMockListUnsentParams{}

	m.UpdateMessageStatusMock = mOutboxRepoMockUpdateMessageStatus{mock: m}
	m.UpdateMessageStatusMock.callArgs = []*OutboxRepoMockUpdateMessageStatusParams{}

	return m
}

type mOutboxRepoMockAddMessageWithKey struct {
	mock               *OutboxRepoMock
	defaultExpectation *OutboxRepoMockAddMessageWithKeyExpectation
	expectations       []*OutboxRepoMockAddMessageWithKeyExpectation

	callArgs []*OutboxRepoMockAddMessageWithKeyParams
	mutex    sync.RWMutex
}

// OutboxRepoMockAddMessageWithKeyExpectation specifies expectation struct of the OutboxRepo.AddMessageWithKey
type OutboxRepoMockAddMessageWithKeyExpectation struct {
	mock    *OutboxRepoMock
	params  *OutboxRepoMockAddMessageWithKeyParams
	results *OutboxRepoMockAddMessageWithKeyResults
	Counter uint64
}

// OutboxRepoMockAddMessageWithKeyParams contains parameters of the OutboxRepo.AddMessageWithKey
type OutboxRepoMockAddMessageWithKeyParams struct {
	ctx     context.Context
	key     string
	payload []byte
}

// OutboxRepoMockAddMessageWithKeyResults contains results of the OutboxRepo.AddMessageWithKey
type OutboxRepoMockAddMessageWithKeyResults struct {
	err error
}

// Expect sets up expected params for OutboxRepo.AddMessageWithKey
func (mmAddMessageWithKey *mOutboxRepoMockAddMessageWithKey) Expect(ctx context.Context, key string, payload []byte) *mOutboxRepoMockAddMessageWithKey {
	if mmAddMessageWithKey.mock.funcAddMessageWithKey != nil {
		mmAddMessageWithKey.mock.t.Fatalf("OutboxRepoMock.AddMessageWithKey mock is already set by Set")
	}

	if mmAddMessageWithKey.defaultExpectation == nil {
		mmAddMessageWithKey.defaultExpectation = &OutboxRepoMockAddMessageWithKeyExpectation{}
	}

	mmAddMessageWithKey.defaultExpectation.params = &OutboxRepoMockAddMessageWithKeyParams{ctx, key, payload}
	for _, e := range mmAddMessageWithKey.expectations {
		if minimock.Equal(e.params, mmAddMessageWithKey.defaultExpectation.params) {
			mmAddMessageWithKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddMessageWithKey.defaultExpectation.params)
		}
	}

	return mmAddMessageWithKey
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepo.AddMessageWithKey
func (mmAddMessageWithKey *mOutboxRepoMockAddMessageWithKey) Inspect(f func(ctx context.Context, key string, payload []byte)) *mOutboxRepoMockAddMessageWithKey {
	if mmAddMessageWithKey.mock.inspectFuncAddMessageWithKey != nil {
		mmAddMessageWithKey.mock.t.Fatalf("Inspect function is already set for OutboxRepoMock.AddMessageWithKey")
	}

	mmAddMessageWithKey.mock.inspectFuncAddMessageWithKey = f

	return mmAddMessageWithKey
}

// Return sets up results that will be returned by OutboxRepo.AddMessageWithKey
func (mmAddMessageWithKey *mOutboxRepoMockAddMessageWithKey) Return(err error) *OutboxRepoMock {
	if mmAddMessageWithKey.mock.funcAddMessageWithKey != nil {
		mmAddMessageWithKey.mock.t.Fatalf("OutboxRepoMock.AddMessageWithKey mock is already set by Set")
	}

	if mmAddMessageWithKey.defaultExpectation == nil {
		mmAddMessageWithKey.defaultExpectation = &OutboxRepoMockAddMessageWithKeyExpectation{mock: mmAddMessageWithKey.mock}
	}
	mmAddMessageWithKey.defaultExpectation.results = &OutboxRepoMockAddMessageWithKeyResults{err}
	return mmAddMessageWithKey.mock
}

// Set uses given function f to mock the OutboxRepo.AddMessageWithKey method
func (mmAddMessageWithKey *mOutboxRepoMockAddMessageWithKey) Set(f func(ctx context.Context, key string, payload []byte) (err error)) *OutboxRepoMock {
	if mmAddMessageWithKey.defaultExpectation != nil {
		mmAddMessageWithKey.mock.t.Fatalf("Default expectation is already set for the OutboxRepo.AddMessageWithKey method")
	}

	if len(mmAddMessageWithKey.expectations) > 0 {
		mmAddMessageWithKey.mock.t.Fatalf("Some expectations are already set for the OutboxRepo.AddMessageWithKey method")
	}

	mmAddMessageWithKey.mock.funcAddMessageWithKey = f
	return mmAddMessageWithKey.mock
}

// When sets expectation for the OutboxRepo.AddMessageWithKey which will trigger the result defined by the following
// Then helper
func (mmAddMessageWithKey *mOutboxRepoMockAddMessageWithKey) When(ctx context.Context, key string, payload []byte) *OutboxRepoMockAddMessageWithKeyExpectation {
	if mmAddMessageWithKey.mock.funcAddMessageWithKey != nil {
		mmAddMessageWithKey.mock.t.Fatalf("OutboxRepoMock.AddMessageWithKey mock is already set by Set")
	}

	expectation := &OutboxRepoMockAddMessageWithKeyExpectation{
		mock:   mmAddMessageWithKey.mock,
		params: &OutboxRepoMockAddMessageWithKeyParams{ctx, key, payload},
	}
	mmAddMessageWithKey.expectations = append(mmAddMessageWithKey.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepo.AddMessageWithKey return parameters for the expectation previously defined by the When method
func (e *OutboxRepoMockAddMessageWithKeyExpectation) Then(err error) *OutboxRepoMock {
	e.results = &OutboxRepoMockAddMessageWithKeyResults{err}
	return e.mock
}

// AddMessageWithKey implements domain.OutboxRepo
func (mmAddMessageWithKey *OutboxRepoMock) AddMessageWithKey(ctx context.Context, key string, payload []byte) (err error) {
	mm_atomic.AddUint64(&mmAddMessageWithKey.beforeAddMessageWithKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmAddMessageWithKey.afterAddMessageWithKeyCounter, 1)

	if mmAddMessageWithKey.inspectFuncAddMessageWithKey != nil {
		mmAddMessageWithKey.inspectFuncAddMessageWithKey(ctx, key, payload)
	}

	mm_params := &OutboxRepoMockAddMessageWithKeyParams{ctx, key, payload}

	// Record call args
	mmAddMessageWithKey.AddMessageWithKeyMock.mutex.Lock()
	mmAddMessageWithKey.AddMessageWithKeyMock.callArgs = append(mmAddMessageWithKey.AddMessageWithKeyMock.callArgs, mm_params)
	mmAddMessageWithKey.AddMessageWithKeyMock.mutex.Unlock()

	for _, e := range mmAddMessageWithKey.AddMessageWithKeyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddMessageWithKey.AddMessageWithKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddMessageWithKey.AddMessageWithKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmAddMessageWithKey.AddMessageWithKeyMock.defaultExpectation.params
		mm_got := OutboxRepoMockAddMessageWithKeyParams{ctx, key, payload}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddMessageWithKey.t.Errorf("OutboxRepoMock.AddMessageWithKey got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddMessageWithKey.AddMessageWithKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmAddMessageWithKey.t.Fatal("No results are set for the OutboxRepoMock.AddMessageWithKey")
		}
		return (*mm_results).err
	}
	if mmAddMessageWithKey.funcAddMessageWithKey != nil {
		return mmAddMessageWithKey.funcAddMessageWithKey(ctx, key, payload)
	}
	mmAddMessageWithKey.t.Fatalf("Unexpected call to OutboxRepoMock.AddMessageWithKey. %v %v %v", ctx, key, payload)
	return
}

// AddMessageWithKeyAfterCounter returns a count of finished OutboxRepoMock.AddMessageWithKey invocations
func (mmAddMessageWithKey *OutboxRepoMock) AddMessageWithKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageWithKey.afterAddMessageWithKeyCounter)
}

// AddMessageWithKeyBeforeCounter returns a count of OutboxRepoMock.AddMessageWithKey invocations
func (mmAddMessageWithKey *OutboxRepoMock) AddMessageWithKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageWithKey.beforeAddMessageWithKeyCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepoMock.AddMessageWithKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddMessageWithKey *mOutboxRepoMockAddMessageWithKey) Calls() []*OutboxRepoMockAddMessageWithKeyParams {
	mmAddMessageWithKey.mutex.RLock()

	argCopy := make([]*OutboxRepoMockAddMessageWithKeyParams, len(mmAddMessageWithKey.callArgs))
	copy(argCopy, mmAddMessageWithKey.callArgs)

	mmAddMessageWithKey.mutex.RUnlock()

	return argCopy
}

// MinimockAddMessageWithKeyDone returns true if the count of the AddMessageWithKey invocations corresponds
// the number of defined expectations
func (m *OutboxRepoMock) MinimockAddMessageWithKeyDone() bool {
	for _, e := range m.AddMessageWithKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageWithKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddMessageWithKeyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageWithKey != nil && mm_atomic.LoadUint64(&m.afterAddMessageWithKeyCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddMessageWithKeyInspect logs each unmet expectation
func (m *OutboxRepoMock) MinimockAddMessageWithKeyInspect() {
	for _, e := range m.AddMessageWithKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepoMock.AddMessageWithKey with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageWithKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddMessageWithKeyCounter) < 1 {
		if m.AddMessageWithKeyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OutboxRepoMock.AddMessageWithKey")
		} else {
			m.t.Errorf("Expected call to OutboxRepoMock.AddMessageWithKey with params: %#v", *m.AddMessageWithKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageWithKey != nil && mm_atomic.LoadUint64(&m.afterAddMessageWithKeyCounter) < 1 {
		m.t.Error("Expected call to OutboxRepoMock.AddMessageWithKey")
	}
}

type mOutboxRepoMockAddMessageWithoutKey struct {
	mock               *OutboxRepoMock
	defaultExpectation *OutboxRepoMockAddMessageWithoutKeyExpectation
	expectations       []*OutboxRepoMockAddMessageWithoutKeyExpectation

	callArgs []*OutboxRepoMockAddMessageWithoutKeyParams
	mutex    sync.RWMutex
}

// OutboxRepoMockAddMessageWithoutKeyExpectation specifies expectation struct of the OutboxRepo.AddMessageWithoutKey
type OutboxRepoMockAddMessageWithoutKeyExpectation struct {
	mock    *OutboxRepoMock
	params  *OutboxRepoMockAddMessageWithoutKeyParams
	results *OutboxRepoMockAddMessageWithoutKeyResults
	Counter uint64
}

// OutboxRepoMockAddMessageWithoutKeyParams contains parameters of the OutboxRepo.AddMessageWithoutKey
type OutboxRepoMockAddMessageWithoutKeyParams struct {
	ctx     context.Context
	payload []byte
}

// OutboxRepoMockAddMessageWithoutKeyResults contains results of the OutboxRepo.AddMessageWithoutKey
type OutboxRepoMockAddMessageWithoutKeyResults struct {
	err error
}

// Expect sets up expected params for OutboxRepo.AddMessageWithoutKey
func (mmAddMessageWithoutKey *mOutboxRepoMockAddMessageWithoutKey) Expect(ctx context.Context, payload []byte) *mOutboxRepoMockAddMessageWithoutKey {
	if mmAddMessageWithoutKey.mock.funcAddMessageWithoutKey != nil {
		mmAddMessageWithoutKey.mock.t.Fatalf("OutboxRepoMock.AddMessageWithoutKey mock is already set by Set")
	}

	if mmAddMessageWithoutKey.defaultExpectation == nil {
		mmAddMessageWithoutKey.defaultExpectation = &OutboxRepoMockAddMessageWithoutKeyExpectation{}
	}

	mmAddMessageWithoutKey.defaultExpectation.params = &OutboxRepoMockAddMessageWithoutKeyParams{ctx, payload}
	for _, e := range mmAddMessageWithoutKey.expectations {
		if minimock.Equal(e.params, mmAddMessageWithoutKey.defaultExpectation.params) {
			mmAddMessageWithoutKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddMessageWithoutKey.defaultExpectation.params)
		}
	}

	return mmAddMessageWithoutKey
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepo.AddMessageWithoutKey
func (mmAddMessageWithoutKey *mOutboxRepoMockAddMessageWithoutKey) Inspect(f func(ctx context.Context, payload []byte)) *mOutboxRepoMockAddMessageWithoutKey {
	if mmAddMessageWithoutKey.mock.inspectFuncAddMessageWithoutKey != nil {
		mmAddMessageWithoutKey.mock.t.Fatalf("Inspect function is already set for OutboxRepoMock.AddMessageWithoutKey")
	}

	mmAddMessageWithoutKey.mock.inspectFuncAddMessageWithoutKey = f

	return mmAddMessageWithoutKey
}

// Return sets up results that will be returned by OutboxRepo.AddMessageWithoutKey
func (mmAddMessageWithoutKey *mOutboxRepoMockAddMessageWithoutKey) Return(err error) *OutboxRepoMock {
	if mmAddMessageWithoutKey.mock.funcAddMessageWithoutKey != nil {
		mmAddMessageWithoutKey.mock.t.Fatalf("OutboxRepoMock.AddMessageWithoutKey mock is already set by Set")
	}

	if mmAddMessageWithoutKey.defaultExpectation == nil {
		mmAddMessageWithoutKey.defaultExpectation = &OutboxRepoMockAddMessageWithoutKeyExpectation{mock: mmAddMessageWithoutKey.mock}
	}
	mmAddMessageWithoutKey.defaultExpectation.results = &OutboxRepoMockAddMessageWithoutKeyResults{err}
	return mmAddMessageWithoutKey.mock
}

// Set uses given function f to mock the OutboxRepo.AddMessageWithoutKey method
func (mmAddMessageWithoutKey *mOutboxRepoMockAddMessageWithoutKey) Set(f func(ctx context.Context, payload []byte) (err error)) *OutboxRepoMock {
	if mmAddMessageWithoutKey.defaultExpectation != nil {
		mmAddMessageWithoutKey.mock.t.Fatalf("Default expectation is already set for the OutboxRepo.AddMessageWithoutKey method")
	}

	if len(mmAddMessageWithoutKey.expectations) > 0 {
		mmAddMessageWithoutKey.mock.t.Fatalf("Some expectations are already set for the OutboxRepo.AddMessageWithoutKey method")
	}

	mmAddMessageWithoutKey.mock.funcAddMessageWithoutKey = f
	return mmAddMessageWithoutKey.mock
}

// When sets expectation for the OutboxRepo.AddMessageWithoutKey which will trigger the result defined by the following
// Then helper
func (mmAddMessageWithoutKey *mOutboxRepoMockAddMessageWithoutKey) When(ctx context.Context, payload []byte) *OutboxRepoMockAddMessageWithoutKeyExpectation {
	if mmAddMessageWithoutKey.mock.funcAddMessageWithoutKey != nil {
		mmAddMessageWithoutKey.mock.t.Fatalf("OutboxRepoMock.AddMessageWithoutKey mock is already set by Set")
	}

	expectation := &OutboxRepoMockAddMessageWithoutKeyExpectation{
		mock:   mmAddMessageWithoutKey.mock,
		params: &OutboxRepoMockAddMessageWithoutKeyParams{ctx, payload},
	}
	mmAddMessageWithoutKey.expectations = append(mmAddMessageWithoutKey.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepo.AddMessageWithoutKey return parameters for the expectation previously defined by the When method
func (e *OutboxRepoMockAddMessageWithoutKeyExpectation) Then(err error) *OutboxRepoMock {
	e.results = &OutboxRepoMockAddMessageWithoutKeyResults{err}
	return e.mock
}

// AddMessageWithoutKey implements domain.OutboxRepo
func (mmAddMessageWithoutKey *OutboxRepoMock) AddMessageWithoutKey(ctx context.Context, payload []byte) (err error) {
	mm_atomic.AddUint64(&mmAddMessageWithoutKey.beforeAddMessageWithoutKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmAddMessageWithoutKey.afterAddMessageWithoutKeyCounter, 1)

	if mmAddMessageWithoutKey.inspectFuncAddMessageWithoutKey != nil {
		mmAddMessageWithoutKey.inspectFuncAddMessageWithoutKey(ctx, payload)
	}

	mm_params := &OutboxRepoMockAddMessageWithoutKeyParams{ctx, payload}

	// Record call args
	mmAddMessageWithoutKey.AddMessageWithoutKeyMock.mutex.Lock()
	mmAddMessageWithoutKey.AddMessageWithoutKeyMock.callArgs = append(mmAddMessageWithoutKey.AddMessageWithoutKeyMock.callArgs, mm_params)
	mmAddMessageWithoutKey.AddMessageWithoutKeyMock.mutex.Unlock()

	for _, e := range mmAddMessageWithoutKey.AddMessageWithoutKeyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddMessageWithoutKey.AddMessageWithoutKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddMessageWithoutKey.AddMessageWithoutKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmAddMessageWithoutKey.AddMessageWithoutKeyMock.defaultExpectation.params
		mm_got := OutboxRepoMockAddMessageWithoutKeyParams{ctx, payload}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddMessageWithoutKey.t.Errorf("OutboxRepoMock.AddMessageWithoutKey got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddMessageWithoutKey.AddMessageWithoutKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmAddMessageWithoutKey.t.Fatal("No results are set for the OutboxRepoMock.AddMessageWithoutKey")
		}
		return (*mm_results).err
	}
	if mmAddMessageWithoutKey.funcAddMessageWithoutKey != nil {
		return mmAddMessageWithoutKey.funcAddMessageWithoutKey(ctx, payload)
	}
	mmAddMessageWithoutKey.t.Fatalf("Unexpected call to OutboxRepoMock.AddMessageWithoutKey. %v %v", ctx, payload)
	return
}

// AddMessageWithoutKeyAfterCounter returns a count of finished OutboxRepoMock.AddMessageWithoutKey invocations
func (mmAddMessageWithoutKey *OutboxRepoMock) AddMessageWithoutKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageWithoutKey.afterAddMessageWithoutKeyCounter)
}

// AddMessageWithoutKeyBeforeCounter returns a count of OutboxRepoMock.AddMessageWithoutKey invocations
func (mmAddMessageWithoutKey *OutboxRepoMock) AddMessageWithoutKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageWithoutKey.beforeAddMessageWithoutKeyCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepoMock.AddMessageWithoutKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddMessageWithoutKey *mOutboxRepoMockAddMessageWithoutKey) Calls() []*OutboxRepoMockAddMessageWithoutKeyParams {
	mmAddMessageWithoutKey.mutex.RLock()

	argCopy := make([]*OutboxRepoMockAddMessageWithoutKeyParams, len(mmAddMessageWithoutKey.callArgs))
	copy(argCopy, mmAddMessageWithoutKey.callArgs)

	mmAddMessageWithoutKey.mutex.RUnlock()

	return argCopy
}

// MinimockAddMessageWithoutKeyDone returns true if the count of the AddMessageWithoutKey invocations corresponds
// the number of defined expectations
func (m *OutboxRepoMock) MinimockAddMessageWithoutKeyDone() bool {
	for _, e := range m.AddMessageWithoutKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageWithoutKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddMessageWithoutKeyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageWithoutKey != nil && mm_atomic.LoadUint64(&m.afterAddMessageWithoutKeyCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddMessageWithoutKeyInspect logs each unmet expectation
func (m *OutboxRepoMock) MinimockAddMessageWithoutKeyInspect() {
	for _, e := range m.AddMessageWithoutKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepoMock.AddMessageWithoutKey with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageWithoutKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddMessageWithoutKeyCounter) < 1 {
		if m.AddMessageWithoutKeyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OutboxRepoMock.AddMessageWithoutKey")
		} else {
			m.t.Errorf("Expected call to OutboxRepoMock.AddMessageWithoutKey with params: %#v", *m.AddMessageWithoutKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageWithoutKey != nil && mm_atomic.LoadUint64(&m.afterAddMessageWithoutKeyCounter) < 1 {
		m.t.Error("Expected call to OutboxRepoMock.AddMessageWithoutKey")
	}
}

type mOutboxRepoMockDeleteMessage struct {
	mock               *OutboxRepoMock
	defaultExpectation *OutboxRepoMockDeleteMessageExpectation
	expectations       []*OutboxRepoMockDeleteMessageExpectation

	callArgs []*OutboxRepoMockDeleteMessageParams
	mutex    sync.RWMutex
}

// OutboxRepoMockDeleteMessageExpectation specifies expectation struct of the OutboxRepo.DeleteMessage
type OutboxRepoMockDeleteMessageExpectation struct {
	mock    *OutboxRepoMock
	params  *OutboxRepoMockDeleteMessageParams
	results *OutboxRepoMockDeleteMessageResults
	Counter uint64
}

// OutboxRepoMockDeleteMessageParams contains parameters of the OutboxRepo.DeleteMessage
type OutboxRepoMockDeleteMessageParams struct {
	ctx context.Context
	id  int64
}

// OutboxRepoMockDeleteMessageResults contains results of the OutboxRepo.DeleteMessage
type OutboxRepoMockDeleteMessageResults struct {
	err error
}

// Expect sets up expected params for OutboxRepo.DeleteMessage
func (mmDeleteMessage *mOutboxRepoMockDeleteMessage) Expect(ctx context.Context, id int64) *mOutboxRepoMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("OutboxRepoMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &OutboxRepoMockDeleteMessageExpectation{}
	}

	mmDeleteMessage.defaultExpectation.params = &OutboxRepoMockDeleteMessageParams{ctx, id}
	for _, e := range mmDeleteMessage.expectations {
		if minimock.Equal(e.params, mmDeleteMessage.defaultExpectation.params) {
			mmDeleteMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteMessage.defaultExpectation.params)
		}
	}

	return mmDeleteMessage
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepo.DeleteMessage
func (mmDeleteMessage *mOutboxRepoMockDeleteMessage) Inspect(f func(ctx context.Context, id int64)) *mOutboxRepoMockDeleteMessage {
	if mmDeleteMessage.mock.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("Inspect function is already set for OutboxRepoMock.DeleteMessage")
	}

	mmDeleteMessage.mock.inspectFuncDeleteMessage = f

	return mmDeleteMessage
}

// Return sets up results that will be returned by OutboxRepo.DeleteMessage
func (mmDeleteMessage *mOutboxRepoMockDeleteMessage) Return(err error) *OutboxRepoMock {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("OutboxRepoMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &OutboxRepoMockDeleteMessageExpectation{mock: mmDeleteMessage.mock}
	}
	mmDeleteMessage.defaultExpectation.results = &OutboxRepoMockDeleteMessageResults{err}
	return mmDeleteMessage.mock
}

// Set uses given function f to mock the OutboxRepo.DeleteMessage method
func (mmDeleteMessage *mOutboxRepoMockDeleteMessage) Set(f func(ctx context.Context, id int64) (err error)) *OutboxRepoMock {
	if mmDeleteMessage.defaultExpectation != nil {
		mmDeleteMessage.mock.t.Fatalf("Default expectation is already set for the OutboxRepo.DeleteMessage method")
	}

	if len(mmDeleteMessage.expectations) > 0 {
		mmDeleteMessage.mock.t.Fatalf("Some expectations are already set for the OutboxRepo.DeleteMessage method")
	}

	mmDeleteMessage.mock.funcDeleteMessage = f
	return mmDeleteMessage.mock
}

// When sets expectation for the OutboxRepo.DeleteMessage which will trigger the result defined by the following
// Then helper
func (mmDeleteMessage *mOutboxRepoMockDeleteMessage) When(ctx context.Context, id int64) *OutboxRepoMockDeleteMessageExpectation {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("OutboxRepoMock.DeleteMessage mock is already set by Set")
	}

	expectation := &OutboxRepoMockDeleteMessageExpectation{
		mock:   mmDeleteMessage.mock,
		params: &OutboxRepoMockDeleteMessageParams{ctx, id},
	}
	mmDeleteMessage.expectations = append(mmDeleteMessage.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepo.DeleteMessage return parameters for the expectation previously defined by the When method
func (e *OutboxRepoMockDeleteMessageExpectation) Then(err error) *OutboxRepoMock {
	e.results = &OutboxRepoMockDeleteMessageResults{err}
	return e.mock
}

// DeleteMessage implements domain.OutboxRepo
func (mmDeleteMessage *OutboxRepoMock) DeleteMessage(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteMessage.beforeDeleteMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteMessage.afterDeleteMessageCounter, 1)

	if mmDeleteMessage.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.inspectFuncDeleteMessage(ctx, id)
	}

	mm_params := &OutboxRepoMockDeleteMessageParams{ctx, id}

	// Record call args
	mmDeleteMessage.DeleteMessageMock.mutex.Lock()
	mmDeleteMessage.DeleteMessageMock.callArgs = append(mmDeleteMessage.DeleteMessageMock.callArgs, mm_params)
	mmDeleteMessage.DeleteMessageMock.mutex.Unlock()

	for _, e := range mmDeleteMessage.DeleteMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteMessage.DeleteMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteMessage.DeleteMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteMessage.DeleteMessageMock.defaultExpectation.params
		mm_got := OutboxRepoMockDeleteMessageParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteMessage.t.Errorf("OutboxRepoMock.DeleteMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteMessage.DeleteMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteMessage.t.Fatal("No results are set for the OutboxRepoMock.DeleteMessage")
		}
		return (*mm_results).err
	}
	if mmDeleteMessage.funcDeleteMessage != nil {
		return mmDeleteMessage.funcDeleteMessage(ctx, id)
	}
	mmDeleteMessage.t.Fatalf("Unexpected call to OutboxRepoMock.DeleteMessage. %v %v", ctx, id)
	return
}

// DeleteMessageAfterCounter returns a count of finished OutboxRepoMock.DeleteMessage invocations
func (mmDeleteMessage *OutboxRepoMock) DeleteMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.afterDeleteMessageCounter)
}

// DeleteMessageBeforeCounter returns a count of OutboxRepoMock.DeleteMessage invocations
func (mmDeleteMessage *OutboxRepoMock) DeleteMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.beforeDeleteMessageCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepoMock.DeleteMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteMessage *mOutboxRepoMockDeleteMessage) Calls() []*OutboxRepoMockDeleteMessageParams {
	mmDeleteMessage.mutex.RLock()

	argCopy := make([]*OutboxRepoMockDeleteMessageParams, len(mmDeleteMessage.callArgs))
	copy(argCopy, mmDeleteMessage.callArgs)

	mmDeleteMessage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteMessageDone returns true if the count of the DeleteMessage invocations corresponds
// the number of defined expectations
func (m *OutboxRepoMock) MinimockDeleteMessageDone() bool {
	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMessage != nil && mm_atomic.LoadUint64(&m.afterDeleteMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteMessageInspect logs each unmet expectation
func (m *OutboxRepoMock) MinimockDeleteMessageInspect() {
	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepoMock.DeleteMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteMessageCounter) < 1 {
		if m.DeleteMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OutboxRepoMock.DeleteMessage")
		} else {
			m.t.Errorf("Expected call to OutboxRepoMock.DeleteMessage with params: %#v", *m.DeleteMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMessage != nil && mm_atomic.LoadUint64(&m.afterDeleteMessageCounter) < 1 {
		m.t.Error("Expected call to OutboxRepoMock.DeleteMessage")
	}
}

type mOutboxRepoMockListUnsent struct {
	mock               *OutboxRepoMock
	defaultExpectation *OutboxRepoMockListUnsentExpectation
	expectations       []*OutboxRepoMockListUnsentExpectation

	callArgs []*OutboxRepoMockListUnsentParams
	mutex    sync.RWMutex
}

// OutboxRepoMockListUnsentExpectation specifies expectation struct of the OutboxRepo.ListUnsent
type OutboxRepoMockListUnsentExpectation struct {
	mock    *OutboxRepoMock
	params  *OutboxRepoMockListUnsentParams
	results *OutboxRepoMockListUnsentResults
	Counter uint64
}

// OutboxRepoMockListUnsentParams contains parameters of the OutboxRepo.ListUnsent
type OutboxRepoMockListUnsentParams struct {
	ctx context.Context
}

// OutboxRepoMockListUnsentResults contains results of the OutboxRepo.ListUnsent
type OutboxRepoMockListUnsentResults struct {
	ma1 []outbox.Message
	err error
}

// Expect sets up expected params for OutboxRepo.ListUnsent
func (mmListUnsent *mOutboxRepoMockListUnsent) Expect(ctx context.Context) *mOutboxRepoMockListUnsent {
	if mmListUnsent.mock.funcListUnsent != nil {
		mmListUnsent.mock.t.Fatalf("OutboxRepoMock.ListUnsent mock is already set by Set")
	}

	if mmListUnsent.defaultExpectation == nil {
		mmListUnsent.defaultExpectation = &OutboxRepoMockListUnsentExpectation{}
	}

	mmListUnsent.defaultExpectation.params = &OutboxRepoMockListUnsentParams{ctx}
	for _, e := range mmListUnsent.expectations {
		if minimock.Equal(e.params, mmListUnsent.defaultExpectation.params) {
			mmListUnsent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListUnsent.defaultExpectation.params)
		}
	}

	return mmListUnsent
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepo.ListUnsent
func (mmListUnsent *mOutboxRepoMockListUnsent) Inspect(f func(ctx context.Context)) *mOutboxRepoMockListUnsent {
	if mmListUnsent.mock.inspectFuncListUnsent != nil {
		mmListUnsent.mock.t.Fatalf("Inspect function is already set for OutboxRepoMock.ListUnsent")
	}

	mmListUnsent.mock.inspectFuncListUnsent = f

	return mmListUnsent
}

// Return sets up results that will be returned by OutboxRepo.ListUnsent
func (mmListUnsent *mOutboxRepoMockListUnsent) Return(ma1 []outbox.Message, err error) *OutboxRepoMock {
	if mmListUnsent.mock.funcListUnsent != nil {
		mmListUnsent.mock.t.Fatalf("OutboxRepoMock.ListUnsent mock is already set by Set")
	}

	if mmListUnsent.defaultExpectation == nil {
		mmListUnsent.defaultExpectation = &OutboxRepoMockListUnsentExpectation{mock: mmListUnsent.mock}
	}
	mmListUnsent.defaultExpectation.results = &OutboxRepoMockListUnsentResults{ma1, err}
	return mmListUnsent.mock
}

// Set uses given function f to mock the OutboxRepo.ListUnsent method
func (mmListUnsent *mOutboxRepoMockListUnsent) Set(f func(ctx context.Context) (ma1 []outbox.Message, err error)) *OutboxRepoMock {
	if mmListUnsent.defaultExpectation != nil {
		mmListUnsent.mock.t.Fatalf("Default expectation is already set for the OutboxRepo.ListUnsent method")
	}

	if len(mmListUnsent.expectations) > 0 {
		mmListUnsent.mock.t.Fatalf("Some expectations are already set for the OutboxRepo.ListUnsent method")
	}

	mmListUnsent.mock.funcListUnsent = f
	return mmListUnsent.mock
}

// When sets expectation for the OutboxRepo.ListUnsent which will trigger the result defined by the following
// Then helper
func (mmListUnsent *mOutboxRepoMockListUnsent) When(ctx context.Context) *OutboxRepoMockListUnsentExpectation {
	if mmListUnsent.mock.funcListUnsent != nil {
		mmListUnsent.mock.t.Fatalf("OutboxRepoMock.ListUnsent mock is already set by Set")
	}

	expectation := &OutboxRepoMockListUnsentExpectation{
		mock:   mmListUnsent.mock,
		params: &OutboxRepoMockListUnsentParams{ctx},
	}
	mmListUnsent.expectations = append(mmListUnsent.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepo.ListUnsent return parameters for the expectation previously defined by the When method
func (e *OutboxRepoMockListUnsentExpectation) Then(ma1 []outbox.Message, err error) *OutboxRepoMock {
	e.results = &OutboxRepoMockListUnsentResults{ma1, err}
	return e.mock
}

// ListUnsent implements domain.OutboxRepo
func (mmListUnsent *OutboxRepoMock) ListUnsent(ctx context.Context) (ma1 []outbox.Message, err error) {
	mm_atomic.AddUint64(&mmListUnsent.beforeListUnsentCounter, 1)
	defer mm_atomic.AddUint64(&mmListUnsent.afterListUnsentCounter, 1)

	if mmListUnsent.inspectFuncListUnsent != nil {
		mmListUnsent.inspectFuncListUnsent(ctx)
	}

	mm_params := &OutboxRepoMockListUnsentParams{ctx}

	// Record call args
	mmListUnsent.ListUnsentMock.mutex.Lock()
	mmListUnsent.ListUnsentMock.callArgs = append(mmListUnsent.ListUnsentMock.callArgs, mm_params)
	mmListUnsent.ListUnsentMock.mutex.Unlock()

	for _, e := range mmListUnsent.ListUnsentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmListUnsent.ListUnsentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListUnsent.ListUnsentMock.defaultExpectation.Counter, 1)
		mm_want := mmListUnsent.ListUnsentMock.defaultExpectation.params
		mm_got := OutboxRepoMockListUnsentParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListUnsent.t.Errorf("OutboxRepoMock.ListUnsent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListUnsent.ListUnsentMock.defaultExpectation.results
		if mm_results == nil {
			mmListUnsent.t.Fatal("No results are set for the OutboxRepoMock.ListUnsent")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmListUnsent.funcListUnsent != nil {
		return mmListUnsent.funcListUnsent(ctx)
	}
	mmListUnsent.t.Fatalf("Unexpected call to OutboxRepoMock.ListUnsent. %v", ctx)
	return
}

// ListUnsentAfterCounter returns a count of finished OutboxRepoMock.ListUnsent invocations
func (mmListUnsent *OutboxRepoMock) ListUnsentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUnsent.afterListUnsentCounter)
}

// ListUnsentBeforeCounter returns a count of OutboxRepoMock.ListUnsent invocations
func (mmListUnsent *OutboxRepoMock) ListUnsentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUnsent.beforeListUnsentCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepoMock.ListUnsent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListUnsent *mOutboxRepoMockListUnsent) Calls() []*OutboxRepoMockListUnsentParams {
	mmListUnsent.mutex.RLock()

	argCopy := make([]*OutboxRepoMockListUnsentParams, len(mmListUnsent.callArgs))
	copy(argCopy, mmListUnsent.callArgs)

	mmListUnsent.mutex.RUnlock()

	return argCopy
}

// MinimockListUnsentDone returns true if the count of the ListUnsent invocations corresponds
// the number of defined expectations
func (m *OutboxRepoMock) MinimockListUnsentDone() bool {
	for _, e := range m.ListUnsentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListUnsentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListUnsentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListUnsent != nil && mm_atomic.LoadUint64(&m.afterListUnsentCounter) < 1 {
		return false
	}
	return true
}

// MinimockListUnsentInspect logs each unmet expectation
func (m *OutboxRepoMock) MinimockListUnsentInspect() {
	for _, e := range m.ListUnsentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepoMock.ListUnsent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListUnsentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListUnsentCounter) < 1 {
		if m.ListUnsentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OutboxRepoMock.ListUnsent")
		} else {
			m.t.Errorf("Expected call to OutboxRepoMock.ListUnsent with params: %#v", *m.ListUnsentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListUnsent != nil && mm_atomic.LoadUint64(&m.afterListUnsentCounter) < 1 {
		m.t.Error("Expected call to OutboxRepoMock.ListUnsent")
	}
}

type mOutboxRepoMockUpdateMessageStatus struct {
	mock               *OutboxRepoMock
	defaultExpectation *OutboxRepoMockUpdateMessageStatusExpectation
	expectations       []*OutboxRepoMockUpdateMessageStatusExpectation

	callArgs []*OutboxRepoMockUpdateMessageStatusParams
	mutex    sync.RWMutex
}

// OutboxRepoMockUpdateMessageStatusExpectation specifies expectation struct of the OutboxRepo.UpdateMessageStatus
type OutboxRepoMockUpdateMessageStatusExpectation struct {
	mock    *OutboxRepoMock
	params  *OutboxRepoMockUpdateMessageStatusParams
	results *OutboxRepoMockUpdateMessageStatusResults
	Counter uint64
}

// OutboxRepoMockUpdateMessageStatusParams contains parameters of the OutboxRepo.UpdateMessageStatus
type OutboxRepoMockUpdateMessageStatusParams struct {
	ctx    context.Context
	id     int64
	status outbox.Status
}

// OutboxRepoMockUpdateMessageStatusResults contains results of the OutboxRepo.UpdateMessageStatus
type OutboxRepoMockUpdateMessageStatusResults struct {
	err error
}

// Expect sets up expected params for OutboxRepo.UpdateMessageStatus
func (mmUpdateMessageStatus *mOutboxRepoMockUpdateMessageStatus) Expect(ctx context.Context, id int64, status outbox.Status) *mOutboxRepoMockUpdateMessageStatus {
	if mmUpdateMessageStatus.mock.funcUpdateMessageStatus != nil {
		mmUpdateMessageStatus.mock.t.Fatalf("OutboxRepoMock.UpdateMessageStatus mock is already set by Set")
	}

	if mmUpdateMessageStatus.defaultExpectation == nil {
		mmUpdateMessageStatus.defaultExpectation = &OutboxRepoMockUpdateMessageStatusExpectation{}
	}

	mmUpdateMessageStatus.defaultExpectation.params = &OutboxRepoMockUpdateMessageStatusParams{ctx, id, status}
	for _, e := range mmUpdateMessageStatus.expectations {
		if minimock.Equal(e.params, mmUpdateMessageStatus.defaultExpectation.params) {
			mmUpdateMessageStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateMessageStatus.defaultExpectation.params)
		}
	}

	return mmUpdateMessageStatus
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepo.UpdateMessageStatus
func (mmUpdateMessageStatus *mOutboxRepoMockUpdateMessageStatus) Inspect(f func(ctx context.Context, id int64, status outbox.Status)) *mOutboxRepoMockUpdateMessageStatus {
	if mmUpdateMessageStatus.mock.inspectFuncUpdateMessageStatus != nil {
		mmUpdateMessageStatus.mock.t.Fatalf("Inspect function is already set for OutboxRepoMock.UpdateMessageStatus")
	}

	mmUpdateMessageStatus.mock.inspectFuncUpdateMessageStatus = f

	return mmUpdateMessageStatus
}

// Return sets up results that will be returned by OutboxRepo.UpdateMessageStatus
func (mmUpdateMessageStatus *mOutboxRepoMockUpdateMessageStatus) Return(err error) *OutboxRepoMock {
	if mmUpdateMessageStatus.mock.funcUpdateMessageStatus != nil {
		mmUpdateMessageStatus.mock.t.Fatalf("OutboxRepoMock.UpdateMessageStatus mock is already set by Set")
	}

	if mmUpdateMessageStatus.defaultExpectation == nil {
		mmUpdateMessageStatus.defaultExpectation = &OutboxRepoMockUpdateMessageStatusExpectation{mock: mmUpdateMessageStatus.mock}
	}
	mmUpdateMessageStatus.defaultExpectation.results = &OutboxRepoMockUpdateMessageStatusResults{err}
	return mmUpdateMessageStatus.mock
}

// Set uses given function f to mock the OutboxRepo.UpdateMessageStatus method
func (mmUpdateMessageStatus *mOutboxRepoMockUpdateMessageStatus) Set(f func(ctx context.Context, id int64, status outbox.Status) (err error)) *OutboxRepoMock {
	if mmUpdateMessageStatus.defaultExpectation != nil {
		mmUpdateMessageStatus.mock.t.Fatalf("Default expectation is already set for the OutboxRepo.UpdateMessageStatus method")
	}

	if len(mmUpdateMessageStatus.expectations) > 0 {
		mmUpdateMessageStatus.mock.t.Fatalf("Some expectations are already set for the OutboxRepo.UpdateMessageStatus method")
	}

	mmUpdateMessageStatus.mock.funcUpdateMessageStatus = f
	return mmUpdateMessageStatus.mock
}

// When sets expectation for the OutboxRepo.UpdateMessageStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateMessageStatus *mOutboxRepoMockUpdateMessageStatus) When(ctx context.Context, id int64, status outbox.Status) *OutboxRepoMockUpdateMessageStatusExpectation {
	if mmUpdateMessageStatus.mock.funcUpdateMessageStatus != nil {
		mmUpdateMessageStatus.mock.t.Fatalf("OutboxRepoMock.UpdateMessageStatus mock is already set by Set")
	}

	expectation := &OutboxRepoMockUpdateMessageStatusExpectation{
		mock:   mmUpdateMessageStatus.mock,
		params: &OutboxRepoMockUpdateMessageStatusParams{ctx, id, status},
	}
	mmUpdateMessageStatus.expectations = append(mmUpdateMessageStatus.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepo.UpdateMessageStatus return parameters for the expectation previously defined by the When method
func (e *OutboxRepoMockUpdateMessageStatusExpectation) Then(err error) *OutboxRepoMock {
	e.results = &OutboxRepoMockUpdateMessageStatusResults{err}
	return e.mock
}

// UpdateMessageStatus implements domain.OutboxRepo
func (mmUpdateMessageStatus *OutboxRepoMock) UpdateMessageStatus(ctx context.Context, id int64, status outbox.Status) (err error) {
	mm_atomic.AddUint64(&mmUpdateMessageStatus.beforeUpdateMessageStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateMessageStatus.afterUpdateMessageStatusCounter, 1)

	if mmUpdateMessageStatus.inspectFuncUpdateMessageStatus != nil {
		mmUpdateMessageStatus.inspectFuncUpdateMessageStatus(ctx, id, status)
	}

	mm_params := &OutboxRepoMockUpdateMessageStatusParams{ctx, id, status}

	// Record call args
	mmUpdateMessageStatus.UpdateMessageStatusMock.mutex.Lock()
	mmUpdateMessageStatus.UpdateMessageStatusMock.callArgs = append(mmUpdateMessageStatus.UpdateMessageStatusMock.callArgs, mm_params)
	mmUpdateMessageStatus.UpdateMessageStatusMock.mutex.Unlock()

	for _, e := range mmUpdateMessageStatus.UpdateMessageStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateMessageStatus.UpdateMessageStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateMessageStatus.UpdateMessageStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateMessageStatus.UpdateMessageStatusMock.defaultExpectation.params
		mm_got := OutboxRepoMockUpdateMessageStatusParams{ctx, id, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateMessageStatus.t.Errorf("OutboxRepoMock.UpdateMessageStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateMessageStatus.UpdateMessageStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateMessageStatus.t.Fatal("No results are set for the OutboxRepoMock.UpdateMessageStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateMessageStatus.funcUpdateMessageStatus != nil {
		return mmUpdateMessageStatus.funcUpdateMessageStatus(ctx, id, status)
	}
	mmUpdateMessageStatus.t.Fatalf("Unexpected call to OutboxRepoMock.UpdateMessageStatus. %v %v %v", ctx, id, status)
	return
}

// UpdateMessageStatusAfterCounter returns a count of finished OutboxRepoMock.UpdateMessageStatus invocations
func (mmUpdateMessageStatus *OutboxRepoMock) UpdateMessageStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMessageStatus.afterUpdateMessageStatusCounter)
}

// UpdateMessageStatusBeforeCounter returns a count of OutboxRepoMock.UpdateMessageStatus invocations
func (mmUpdateMessageStatus *OutboxRepoMock) UpdateMessageStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMessageStatus.beforeUpdateMessageStatusCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepoMock.UpdateMessageStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateMessageStatus *mOutboxRepoMockUpdateMessageStatus) Calls() []*OutboxRepoMockUpdateMessageStatusParams {
	mmUpdateMessageStatus.mutex.RLock()

	argCopy := make([]*OutboxRepoMockUpdateMessageStatusParams, len(mmUpdateMessageStatus.callArgs))
	copy(argCopy, mmUpdateMessageStatus.callArgs)

	mmUpdateMessageStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateMessageStatusDone returns true if the count of the UpdateMessageStatus invocations corresponds
// the number of defined expectations
func (m *OutboxRepoMock) MinimockUpdateMessageStatusDone() bool {
	for _, e := range m.UpdateMessageStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMessageStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateMessageStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateMessageStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateMessageStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateMessageStatusInspect logs each unmet expectation
func (m *OutboxRepoMock) MinimockUpdateMessageStatusInspect() {
	for _, e := range m.UpdateMessageStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepoMock.UpdateMessageStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMessageStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateMessageStatusCounter) < 1 {
		if m.UpdateMessageStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OutboxRepoMock.UpdateMessageStatus")
		} else {
			m.t.Errorf("Expected call to OutboxRepoMock.UpdateMessageStatus with params: %#v", *m.UpdateMessageStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateMessageStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateMessageStatusCounter) < 1 {
		m.t.Error("Expected call to OutboxRepoMock.UpdateMessageStatus")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OutboxRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddMessageWithKeyInspect()

		m.MinimockAddMessageWithoutKeyInspect()

		m.MinimockDeleteMessageInspect()

		m.MinimockListUnsentInspect()

		m.MinimockUpdateMessageStatusInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OutboxRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OutboxRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddMessageWithKeyDone() &&
		m.MinimockAddMessageWithoutKeyDone() &&
		m.MinimockDeleteMessageDone() &&
		m.MinimockListUnsentDone() &&
		m.MinimockUpdateMessageStatusDone()
}
