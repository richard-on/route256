package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/domain.LOMSRepo -o ./mocks\loms_repo_minimock.go -n LOMSRepoMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/rragusskiy/homework-1/loms/internal/model"
)

// LOMSRepoMock implements domain.LOMSRepo
type LOMSRepoMock struct {
	t minimock.Tester

	funcCancelOrder          func(ctx context.Context, orderID int64) (err error)
	inspectFuncCancelOrder   func(ctx context.Context, orderID int64)
	afterCancelOrderCounter  uint64
	beforeCancelOrderCounter uint64
	CancelOrderMock          mLOMSRepoMockCancelOrder

	funcChangeOrderStatus          func(ctx context.Context, orderID int64, status model.Status) (err error)
	inspectFuncChangeOrderStatus   func(ctx context.Context, orderID int64, status model.Status)
	afterChangeOrderStatusCounter  uint64
	beforeChangeOrderStatusCounter uint64
	ChangeOrderStatusMock          mLOMSRepoMockChangeOrderStatus

	funcDecreaseStock          func(ctx context.Context, sku int64, stock model.Stock) (err error)
	inspectFuncDecreaseStock   func(ctx context.Context, sku int64, stock model.Stock)
	afterDecreaseStockCounter  uint64
	beforeDecreaseStockCounter uint64
	DecreaseStockMock          mLOMSRepoMockDecreaseStock

	funcGetStocks          func(ctx context.Context, sku uint32) (sa1 []model.Stock, err error)
	inspectFuncGetStocks   func(ctx context.Context, sku uint32)
	afterGetStocksCounter  uint64
	beforeGetStocksCounter uint64
	GetStocksMock          mLOMSRepoMockGetStocks

	funcIncreaseStock          func(ctx context.Context, sku int64, stock model.Stock) (err error)
	inspectFuncIncreaseStock   func(ctx context.Context, sku int64, stock model.Stock)
	afterIncreaseStockCounter  uint64
	beforeIncreaseStockCounter uint64
	IncreaseStockMock          mLOMSRepoMockIncreaseStock

	funcInsertOrderInfo          func(ctx context.Context, order model.Order) (i1 int64, err error)
	inspectFuncInsertOrderInfo   func(ctx context.Context, order model.Order)
	afterInsertOrderInfoCounter  uint64
	beforeInsertOrderInfoCounter uint64
	InsertOrderInfoMock          mLOMSRepoMockInsertOrderInfo

	funcInsertOrderItems          func(ctx context.Context, orderID int64, domainItems []model.Item) (err error)
	inspectFuncInsertOrderItems   func(ctx context.Context, orderID int64, domainItems []model.Item)
	afterInsertOrderItemsCounter  uint64
	beforeInsertOrderItemsCounter uint64
	InsertOrderItemsMock          mLOMSRepoMockInsertOrderItems

	funcListOrderInfo          func(ctx context.Context, orderID int64) (o1 model.Order, err error)
	inspectFuncListOrderInfo   func(ctx context.Context, orderID int64)
	afterListOrderInfoCounter  uint64
	beforeListOrderInfoCounter uint64
	ListOrderInfoMock          mLOMSRepoMockListOrderInfo

	funcListOrderItems          func(ctx context.Context, orderID int64) (ia1 []model.Item, err error)
	inspectFuncListOrderItems   func(ctx context.Context, orderID int64)
	afterListOrderItemsCounter  uint64
	beforeListOrderItemsCounter uint64
	ListOrderItemsMock          mLOMSRepoMockListOrderItems

	funcListUnpaidOrders          func(ctx context.Context, paymentWait time.Duration) (ia1 []int64, err error)
	inspectFuncListUnpaidOrders   func(ctx context.Context, paymentWait time.Duration)
	afterListUnpaidOrdersCounter  uint64
	beforeListUnpaidOrdersCounter uint64
	ListUnpaidOrdersMock          mLOMSRepoMockListUnpaidOrders

	funcPayOrder          func(ctx context.Context, orderID int64) (err error)
	inspectFuncPayOrder   func(ctx context.Context, orderID int64)
	afterPayOrderCounter  uint64
	beforePayOrderCounter uint64
	PayOrderMock          mLOMSRepoMockPayOrder

	funcRemoveItemsFromReserved          func(ctx context.Context, orderID int64) (ia1 []int64, sa1 []model.Stock, err error)
	inspectFuncRemoveItemsFromReserved   func(ctx context.Context, orderID int64)
	afterRemoveItemsFromReservedCounter  uint64
	beforeRemoveItemsFromReservedCounter uint64
	RemoveItemsFromReservedMock          mLOMSRepoMockRemoveItemsFromReserved

	funcReserveItem          func(ctx context.Context, orderID int64, sku int64, stock model.Stock) (err error)
	inspectFuncReserveItem   func(ctx context.Context, orderID int64, sku int64, stock model.Stock)
	afterReserveItemCounter  uint64
	beforeReserveItemCounter uint64
	ReserveItemMock          mLOMSRepoMockReserveItem
}

// NewLOMSRepoMock returns a mock for domain.LOMSRepo
func NewLOMSRepoMock(t minimock.Tester) *LOMSRepoMock {
	m := &LOMSRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelOrderMock = mLOMSRepoMockCancelOrder{mock: m}
	m.CancelOrderMock.callArgs = []*LOMSRepoMockCancelOrderParams{}

	m.ChangeOrderStatusMock = mLOMSRepoMockChangeOrderStatus{mock: m}
	m.ChangeOrderStatusMock.callArgs = []*LOMSRepoMockChangeOrderStatusParams{}

	m.DecreaseStockMock = mLOMSRepoMockDecreaseStock{mock: m}
	m.DecreaseStockMock.callArgs = []*LOMSRepoMockDecreaseStockParams{}

	m.GetStocksMock = mLOMSRepoMockGetStocks{mock: m}
	m.GetStocksMock.callArgs = []*LOMSRepoMockGetStocksParams{}

	m.IncreaseStockMock = mLOMSRepoMockIncreaseStock{mock: m}
	m.IncreaseStockMock.callArgs = []*LOMSRepoMockIncreaseStockParams{}

	m.InsertOrderInfoMock = mLOMSRepoMockInsertOrderInfo{mock: m}
	m.InsertOrderInfoMock.callArgs = []*LOMSRepoMockInsertOrderInfoParams{}

	m.InsertOrderItemsMock = mLOMSRepoMockInsertOrderItems{mock: m}
	m.InsertOrderItemsMock.callArgs = []*LOMSRepoMockInsertOrderItemsParams{}

	m.ListOrderInfoMock = mLOMSRepoMockListOrderInfo{mock: m}
	m.ListOrderInfoMock.callArgs = []*LOMSRepoMockListOrderInfoParams{}

	m.ListOrderItemsMock = mLOMSRepoMockListOrderItems{mock: m}
	m.ListOrderItemsMock.callArgs = []*LOMSRepoMockListOrderItemsParams{}

	m.ListUnpaidOrdersMock = mLOMSRepoMockListUnpaidOrders{mock: m}
	m.ListUnpaidOrdersMock.callArgs = []*LOMSRepoMockListUnpaidOrdersParams{}

	m.PayOrderMock = mLOMSRepoMockPayOrder{mock: m}
	m.PayOrderMock.callArgs = []*LOMSRepoMockPayOrderParams{}

	m.RemoveItemsFromReservedMock = mLOMSRepoMockRemoveItemsFromReserved{mock: m}
	m.RemoveItemsFromReservedMock.callArgs = []*LOMSRepoMockRemoveItemsFromReservedParams{}

	m.ReserveItemMock = mLOMSRepoMockReserveItem{mock: m}
	m.ReserveItemMock.callArgs = []*LOMSRepoMockReserveItemParams{}

	return m
}

type mLOMSRepoMockCancelOrder struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockCancelOrderExpectation
	expectations       []*LOMSRepoMockCancelOrderExpectation

	callArgs []*LOMSRepoMockCancelOrderParams
	mutex    sync.RWMutex
}

// LOMSRepoMockCancelOrderExpectation specifies expectation struct of the LOMSRepo.CancelOrder
type LOMSRepoMockCancelOrderExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockCancelOrderParams
	results *LOMSRepoMockCancelOrderResults
	Counter uint64
}

// LOMSRepoMockCancelOrderParams contains parameters of the LOMSRepo.CancelOrder
type LOMSRepoMockCancelOrderParams struct {
	ctx     context.Context
	orderID int64
}

// LOMSRepoMockCancelOrderResults contains results of the LOMSRepo.CancelOrder
type LOMSRepoMockCancelOrderResults struct {
	err error
}

// Expect sets up expected params for LOMSRepo.CancelOrder
func (mmCancelOrder *mLOMSRepoMockCancelOrder) Expect(ctx context.Context, orderID int64) *mLOMSRepoMockCancelOrder {
	if mmCancelOrder.mock.funcCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("LOMSRepoMock.CancelOrder mock is already set by Set")
	}

	if mmCancelOrder.defaultExpectation == nil {
		mmCancelOrder.defaultExpectation = &LOMSRepoMockCancelOrderExpectation{}
	}

	mmCancelOrder.defaultExpectation.params = &LOMSRepoMockCancelOrderParams{ctx, orderID}
	for _, e := range mmCancelOrder.expectations {
		if minimock.Equal(e.params, mmCancelOrder.defaultExpectation.params) {
			mmCancelOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelOrder.defaultExpectation.params)
		}
	}

	return mmCancelOrder
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.CancelOrder
func (mmCancelOrder *mLOMSRepoMockCancelOrder) Inspect(f func(ctx context.Context, orderID int64)) *mLOMSRepoMockCancelOrder {
	if mmCancelOrder.mock.inspectFuncCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.CancelOrder")
	}

	mmCancelOrder.mock.inspectFuncCancelOrder = f

	return mmCancelOrder
}

// Return sets up results that will be returned by LOMSRepo.CancelOrder
func (mmCancelOrder *mLOMSRepoMockCancelOrder) Return(err error) *LOMSRepoMock {
	if mmCancelOrder.mock.funcCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("LOMSRepoMock.CancelOrder mock is already set by Set")
	}

	if mmCancelOrder.defaultExpectation == nil {
		mmCancelOrder.defaultExpectation = &LOMSRepoMockCancelOrderExpectation{mock: mmCancelOrder.mock}
	}
	mmCancelOrder.defaultExpectation.results = &LOMSRepoMockCancelOrderResults{err}
	return mmCancelOrder.mock
}

// Set uses given function f to mock the LOMSRepo.CancelOrder method
func (mmCancelOrder *mLOMSRepoMockCancelOrder) Set(f func(ctx context.Context, orderID int64) (err error)) *LOMSRepoMock {
	if mmCancelOrder.defaultExpectation != nil {
		mmCancelOrder.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.CancelOrder method")
	}

	if len(mmCancelOrder.expectations) > 0 {
		mmCancelOrder.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.CancelOrder method")
	}

	mmCancelOrder.mock.funcCancelOrder = f
	return mmCancelOrder.mock
}

// When sets expectation for the LOMSRepo.CancelOrder which will trigger the result defined by the following
// Then helper
func (mmCancelOrder *mLOMSRepoMockCancelOrder) When(ctx context.Context, orderID int64) *LOMSRepoMockCancelOrderExpectation {
	if mmCancelOrder.mock.funcCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("LOMSRepoMock.CancelOrder mock is already set by Set")
	}

	expectation := &LOMSRepoMockCancelOrderExpectation{
		mock:   mmCancelOrder.mock,
		params: &LOMSRepoMockCancelOrderParams{ctx, orderID},
	}
	mmCancelOrder.expectations = append(mmCancelOrder.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.CancelOrder return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockCancelOrderExpectation) Then(err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockCancelOrderResults{err}
	return e.mock
}

// CancelOrder implements domain.LOMSRepo
func (mmCancelOrder *LOMSRepoMock) CancelOrder(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmCancelOrder.beforeCancelOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelOrder.afterCancelOrderCounter, 1)

	if mmCancelOrder.inspectFuncCancelOrder != nil {
		mmCancelOrder.inspectFuncCancelOrder(ctx, orderID)
	}

	mm_params := &LOMSRepoMockCancelOrderParams{ctx, orderID}

	// Record call args
	mmCancelOrder.CancelOrderMock.mutex.Lock()
	mmCancelOrder.CancelOrderMock.callArgs = append(mmCancelOrder.CancelOrderMock.callArgs, mm_params)
	mmCancelOrder.CancelOrderMock.mutex.Unlock()

	for _, e := range mmCancelOrder.CancelOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelOrder.CancelOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelOrder.CancelOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelOrder.CancelOrderMock.defaultExpectation.params
		mm_got := LOMSRepoMockCancelOrderParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelOrder.t.Errorf("LOMSRepoMock.CancelOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelOrder.CancelOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelOrder.t.Fatal("No results are set for the LOMSRepoMock.CancelOrder")
		}
		return (*mm_results).err
	}
	if mmCancelOrder.funcCancelOrder != nil {
		return mmCancelOrder.funcCancelOrder(ctx, orderID)
	}
	mmCancelOrder.t.Fatalf("Unexpected call to LOMSRepoMock.CancelOrder. %v %v", ctx, orderID)
	return
}

// CancelOrderAfterCounter returns a count of finished LOMSRepoMock.CancelOrder invocations
func (mmCancelOrder *LOMSRepoMock) CancelOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelOrder.afterCancelOrderCounter)
}

// CancelOrderBeforeCounter returns a count of LOMSRepoMock.CancelOrder invocations
func (mmCancelOrder *LOMSRepoMock) CancelOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelOrder.beforeCancelOrderCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.CancelOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelOrder *mLOMSRepoMockCancelOrder) Calls() []*LOMSRepoMockCancelOrderParams {
	mmCancelOrder.mutex.RLock()

	argCopy := make([]*LOMSRepoMockCancelOrderParams, len(mmCancelOrder.callArgs))
	copy(argCopy, mmCancelOrder.callArgs)

	mmCancelOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCancelOrderDone returns true if the count of the CancelOrder invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockCancelOrderDone() bool {
	for _, e := range m.CancelOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelOrder != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelOrderInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockCancelOrderInspect() {
	for _, e := range m.CancelOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.CancelOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		if m.CancelOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.CancelOrder")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.CancelOrder with params: %#v", *m.CancelOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelOrder != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.CancelOrder")
	}
}

type mLOMSRepoMockChangeOrderStatus struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockChangeOrderStatusExpectation
	expectations       []*LOMSRepoMockChangeOrderStatusExpectation

	callArgs []*LOMSRepoMockChangeOrderStatusParams
	mutex    sync.RWMutex
}

// LOMSRepoMockChangeOrderStatusExpectation specifies expectation struct of the LOMSRepo.ChangeOrderStatus
type LOMSRepoMockChangeOrderStatusExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockChangeOrderStatusParams
	results *LOMSRepoMockChangeOrderStatusResults
	Counter uint64
}

// LOMSRepoMockChangeOrderStatusParams contains parameters of the LOMSRepo.ChangeOrderStatus
type LOMSRepoMockChangeOrderStatusParams struct {
	ctx     context.Context
	orderID int64
	status  model.Status
}

// LOMSRepoMockChangeOrderStatusResults contains results of the LOMSRepo.ChangeOrderStatus
type LOMSRepoMockChangeOrderStatusResults struct {
	err error
}

// Expect sets up expected params for LOMSRepo.ChangeOrderStatus
func (mmChangeOrderStatus *mLOMSRepoMockChangeOrderStatus) Expect(ctx context.Context, orderID int64, status model.Status) *mLOMSRepoMockChangeOrderStatus {
	if mmChangeOrderStatus.mock.funcChangeOrderStatus != nil {
		mmChangeOrderStatus.mock.t.Fatalf("LOMSRepoMock.ChangeOrderStatus mock is already set by Set")
	}

	if mmChangeOrderStatus.defaultExpectation == nil {
		mmChangeOrderStatus.defaultExpectation = &LOMSRepoMockChangeOrderStatusExpectation{}
	}

	mmChangeOrderStatus.defaultExpectation.params = &LOMSRepoMockChangeOrderStatusParams{ctx, orderID, status}
	for _, e := range mmChangeOrderStatus.expectations {
		if minimock.Equal(e.params, mmChangeOrderStatus.defaultExpectation.params) {
			mmChangeOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangeOrderStatus.defaultExpectation.params)
		}
	}

	return mmChangeOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.ChangeOrderStatus
func (mmChangeOrderStatus *mLOMSRepoMockChangeOrderStatus) Inspect(f func(ctx context.Context, orderID int64, status model.Status)) *mLOMSRepoMockChangeOrderStatus {
	if mmChangeOrderStatus.mock.inspectFuncChangeOrderStatus != nil {
		mmChangeOrderStatus.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.ChangeOrderStatus")
	}

	mmChangeOrderStatus.mock.inspectFuncChangeOrderStatus = f

	return mmChangeOrderStatus
}

// Return sets up results that will be returned by LOMSRepo.ChangeOrderStatus
func (mmChangeOrderStatus *mLOMSRepoMockChangeOrderStatus) Return(err error) *LOMSRepoMock {
	if mmChangeOrderStatus.mock.funcChangeOrderStatus != nil {
		mmChangeOrderStatus.mock.t.Fatalf("LOMSRepoMock.ChangeOrderStatus mock is already set by Set")
	}

	if mmChangeOrderStatus.defaultExpectation == nil {
		mmChangeOrderStatus.defaultExpectation = &LOMSRepoMockChangeOrderStatusExpectation{mock: mmChangeOrderStatus.mock}
	}
	mmChangeOrderStatus.defaultExpectation.results = &LOMSRepoMockChangeOrderStatusResults{err}
	return mmChangeOrderStatus.mock
}

// Set uses given function f to mock the LOMSRepo.ChangeOrderStatus method
func (mmChangeOrderStatus *mLOMSRepoMockChangeOrderStatus) Set(f func(ctx context.Context, orderID int64, status model.Status) (err error)) *LOMSRepoMock {
	if mmChangeOrderStatus.defaultExpectation != nil {
		mmChangeOrderStatus.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.ChangeOrderStatus method")
	}

	if len(mmChangeOrderStatus.expectations) > 0 {
		mmChangeOrderStatus.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.ChangeOrderStatus method")
	}

	mmChangeOrderStatus.mock.funcChangeOrderStatus = f
	return mmChangeOrderStatus.mock
}

// When sets expectation for the LOMSRepo.ChangeOrderStatus which will trigger the result defined by the following
// Then helper
func (mmChangeOrderStatus *mLOMSRepoMockChangeOrderStatus) When(ctx context.Context, orderID int64, status model.Status) *LOMSRepoMockChangeOrderStatusExpectation {
	if mmChangeOrderStatus.mock.funcChangeOrderStatus != nil {
		mmChangeOrderStatus.mock.t.Fatalf("LOMSRepoMock.ChangeOrderStatus mock is already set by Set")
	}

	expectation := &LOMSRepoMockChangeOrderStatusExpectation{
		mock:   mmChangeOrderStatus.mock,
		params: &LOMSRepoMockChangeOrderStatusParams{ctx, orderID, status},
	}
	mmChangeOrderStatus.expectations = append(mmChangeOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.ChangeOrderStatus return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockChangeOrderStatusExpectation) Then(err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockChangeOrderStatusResults{err}
	return e.mock
}

// ChangeOrderStatus implements domain.LOMSRepo
func (mmChangeOrderStatus *LOMSRepoMock) ChangeOrderStatus(ctx context.Context, orderID int64, status model.Status) (err error) {
	mm_atomic.AddUint64(&mmChangeOrderStatus.beforeChangeOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmChangeOrderStatus.afterChangeOrderStatusCounter, 1)

	if mmChangeOrderStatus.inspectFuncChangeOrderStatus != nil {
		mmChangeOrderStatus.inspectFuncChangeOrderStatus(ctx, orderID, status)
	}

	mm_params := &LOMSRepoMockChangeOrderStatusParams{ctx, orderID, status}

	// Record call args
	mmChangeOrderStatus.ChangeOrderStatusMock.mutex.Lock()
	mmChangeOrderStatus.ChangeOrderStatusMock.callArgs = append(mmChangeOrderStatus.ChangeOrderStatusMock.callArgs, mm_params)
	mmChangeOrderStatus.ChangeOrderStatusMock.mutex.Unlock()

	for _, e := range mmChangeOrderStatus.ChangeOrderStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChangeOrderStatus.ChangeOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangeOrderStatus.ChangeOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmChangeOrderStatus.ChangeOrderStatusMock.defaultExpectation.params
		mm_got := LOMSRepoMockChangeOrderStatusParams{ctx, orderID, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangeOrderStatus.t.Errorf("LOMSRepoMock.ChangeOrderStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangeOrderStatus.ChangeOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmChangeOrderStatus.t.Fatal("No results are set for the LOMSRepoMock.ChangeOrderStatus")
		}
		return (*mm_results).err
	}
	if mmChangeOrderStatus.funcChangeOrderStatus != nil {
		return mmChangeOrderStatus.funcChangeOrderStatus(ctx, orderID, status)
	}
	mmChangeOrderStatus.t.Fatalf("Unexpected call to LOMSRepoMock.ChangeOrderStatus. %v %v %v", ctx, orderID, status)
	return
}

// ChangeOrderStatusAfterCounter returns a count of finished LOMSRepoMock.ChangeOrderStatus invocations
func (mmChangeOrderStatus *LOMSRepoMock) ChangeOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeOrderStatus.afterChangeOrderStatusCounter)
}

// ChangeOrderStatusBeforeCounter returns a count of LOMSRepoMock.ChangeOrderStatus invocations
func (mmChangeOrderStatus *LOMSRepoMock) ChangeOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeOrderStatus.beforeChangeOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.ChangeOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangeOrderStatus *mLOMSRepoMockChangeOrderStatus) Calls() []*LOMSRepoMockChangeOrderStatusParams {
	mmChangeOrderStatus.mutex.RLock()

	argCopy := make([]*LOMSRepoMockChangeOrderStatusParams, len(mmChangeOrderStatus.callArgs))
	copy(argCopy, mmChangeOrderStatus.callArgs)

	mmChangeOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockChangeOrderStatusDone returns true if the count of the ChangeOrderStatus invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockChangeOrderStatusDone() bool {
	for _, e := range m.ChangeOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChangeOrderStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeOrderStatus != nil && mm_atomic.LoadUint64(&m.afterChangeOrderStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockChangeOrderStatusInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockChangeOrderStatusInspect() {
	for _, e := range m.ChangeOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.ChangeOrderStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChangeOrderStatusCounter) < 1 {
		if m.ChangeOrderStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.ChangeOrderStatus")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.ChangeOrderStatus with params: %#v", *m.ChangeOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeOrderStatus != nil && mm_atomic.LoadUint64(&m.afterChangeOrderStatusCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.ChangeOrderStatus")
	}
}

type mLOMSRepoMockDecreaseStock struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockDecreaseStockExpectation
	expectations       []*LOMSRepoMockDecreaseStockExpectation

	callArgs []*LOMSRepoMockDecreaseStockParams
	mutex    sync.RWMutex
}

// LOMSRepoMockDecreaseStockExpectation specifies expectation struct of the LOMSRepo.DecreaseStock
type LOMSRepoMockDecreaseStockExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockDecreaseStockParams
	results *LOMSRepoMockDecreaseStockResults
	Counter uint64
}

// LOMSRepoMockDecreaseStockParams contains parameters of the LOMSRepo.DecreaseStock
type LOMSRepoMockDecreaseStockParams struct {
	ctx   context.Context
	sku   int64
	stock model.Stock
}

// LOMSRepoMockDecreaseStockResults contains results of the LOMSRepo.DecreaseStock
type LOMSRepoMockDecreaseStockResults struct {
	err error
}

// Expect sets up expected params for LOMSRepo.DecreaseStock
func (mmDecreaseStock *mLOMSRepoMockDecreaseStock) Expect(ctx context.Context, sku int64, stock model.Stock) *mLOMSRepoMockDecreaseStock {
	if mmDecreaseStock.mock.funcDecreaseStock != nil {
		mmDecreaseStock.mock.t.Fatalf("LOMSRepoMock.DecreaseStock mock is already set by Set")
	}

	if mmDecreaseStock.defaultExpectation == nil {
		mmDecreaseStock.defaultExpectation = &LOMSRepoMockDecreaseStockExpectation{}
	}

	mmDecreaseStock.defaultExpectation.params = &LOMSRepoMockDecreaseStockParams{ctx, sku, stock}
	for _, e := range mmDecreaseStock.expectations {
		if minimock.Equal(e.params, mmDecreaseStock.defaultExpectation.params) {
			mmDecreaseStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDecreaseStock.defaultExpectation.params)
		}
	}

	return mmDecreaseStock
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.DecreaseStock
func (mmDecreaseStock *mLOMSRepoMockDecreaseStock) Inspect(f func(ctx context.Context, sku int64, stock model.Stock)) *mLOMSRepoMockDecreaseStock {
	if mmDecreaseStock.mock.inspectFuncDecreaseStock != nil {
		mmDecreaseStock.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.DecreaseStock")
	}

	mmDecreaseStock.mock.inspectFuncDecreaseStock = f

	return mmDecreaseStock
}

// Return sets up results that will be returned by LOMSRepo.DecreaseStock
func (mmDecreaseStock *mLOMSRepoMockDecreaseStock) Return(err error) *LOMSRepoMock {
	if mmDecreaseStock.mock.funcDecreaseStock != nil {
		mmDecreaseStock.mock.t.Fatalf("LOMSRepoMock.DecreaseStock mock is already set by Set")
	}

	if mmDecreaseStock.defaultExpectation == nil {
		mmDecreaseStock.defaultExpectation = &LOMSRepoMockDecreaseStockExpectation{mock: mmDecreaseStock.mock}
	}
	mmDecreaseStock.defaultExpectation.results = &LOMSRepoMockDecreaseStockResults{err}
	return mmDecreaseStock.mock
}

// Set uses given function f to mock the LOMSRepo.DecreaseStock method
func (mmDecreaseStock *mLOMSRepoMockDecreaseStock) Set(f func(ctx context.Context, sku int64, stock model.Stock) (err error)) *LOMSRepoMock {
	if mmDecreaseStock.defaultExpectation != nil {
		mmDecreaseStock.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.DecreaseStock method")
	}

	if len(mmDecreaseStock.expectations) > 0 {
		mmDecreaseStock.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.DecreaseStock method")
	}

	mmDecreaseStock.mock.funcDecreaseStock = f
	return mmDecreaseStock.mock
}

// When sets expectation for the LOMSRepo.DecreaseStock which will trigger the result defined by the following
// Then helper
func (mmDecreaseStock *mLOMSRepoMockDecreaseStock) When(ctx context.Context, sku int64, stock model.Stock) *LOMSRepoMockDecreaseStockExpectation {
	if mmDecreaseStock.mock.funcDecreaseStock != nil {
		mmDecreaseStock.mock.t.Fatalf("LOMSRepoMock.DecreaseStock mock is already set by Set")
	}

	expectation := &LOMSRepoMockDecreaseStockExpectation{
		mock:   mmDecreaseStock.mock,
		params: &LOMSRepoMockDecreaseStockParams{ctx, sku, stock},
	}
	mmDecreaseStock.expectations = append(mmDecreaseStock.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.DecreaseStock return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockDecreaseStockExpectation) Then(err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockDecreaseStockResults{err}
	return e.mock
}

// DecreaseStock implements domain.LOMSRepo
func (mmDecreaseStock *LOMSRepoMock) DecreaseStock(ctx context.Context, sku int64, stock model.Stock) (err error) {
	mm_atomic.AddUint64(&mmDecreaseStock.beforeDecreaseStockCounter, 1)
	defer mm_atomic.AddUint64(&mmDecreaseStock.afterDecreaseStockCounter, 1)

	if mmDecreaseStock.inspectFuncDecreaseStock != nil {
		mmDecreaseStock.inspectFuncDecreaseStock(ctx, sku, stock)
	}

	mm_params := &LOMSRepoMockDecreaseStockParams{ctx, sku, stock}

	// Record call args
	mmDecreaseStock.DecreaseStockMock.mutex.Lock()
	mmDecreaseStock.DecreaseStockMock.callArgs = append(mmDecreaseStock.DecreaseStockMock.callArgs, mm_params)
	mmDecreaseStock.DecreaseStockMock.mutex.Unlock()

	for _, e := range mmDecreaseStock.DecreaseStockMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDecreaseStock.DecreaseStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDecreaseStock.DecreaseStockMock.defaultExpectation.Counter, 1)
		mm_want := mmDecreaseStock.DecreaseStockMock.defaultExpectation.params
		mm_got := LOMSRepoMockDecreaseStockParams{ctx, sku, stock}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDecreaseStock.t.Errorf("LOMSRepoMock.DecreaseStock got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDecreaseStock.DecreaseStockMock.defaultExpectation.results
		if mm_results == nil {
			mmDecreaseStock.t.Fatal("No results are set for the LOMSRepoMock.DecreaseStock")
		}
		return (*mm_results).err
	}
	if mmDecreaseStock.funcDecreaseStock != nil {
		return mmDecreaseStock.funcDecreaseStock(ctx, sku, stock)
	}
	mmDecreaseStock.t.Fatalf("Unexpected call to LOMSRepoMock.DecreaseStock. %v %v %v", ctx, sku, stock)
	return
}

// DecreaseStockAfterCounter returns a count of finished LOMSRepoMock.DecreaseStock invocations
func (mmDecreaseStock *LOMSRepoMock) DecreaseStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecreaseStock.afterDecreaseStockCounter)
}

// DecreaseStockBeforeCounter returns a count of LOMSRepoMock.DecreaseStock invocations
func (mmDecreaseStock *LOMSRepoMock) DecreaseStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecreaseStock.beforeDecreaseStockCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.DecreaseStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDecreaseStock *mLOMSRepoMockDecreaseStock) Calls() []*LOMSRepoMockDecreaseStockParams {
	mmDecreaseStock.mutex.RLock()

	argCopy := make([]*LOMSRepoMockDecreaseStockParams, len(mmDecreaseStock.callArgs))
	copy(argCopy, mmDecreaseStock.callArgs)

	mmDecreaseStock.mutex.RUnlock()

	return argCopy
}

// MinimockDecreaseStockDone returns true if the count of the DecreaseStock invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockDecreaseStockDone() bool {
	for _, e := range m.DecreaseStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecreaseStockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecreaseStockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecreaseStock != nil && mm_atomic.LoadUint64(&m.afterDecreaseStockCounter) < 1 {
		return false
	}
	return true
}

// MinimockDecreaseStockInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockDecreaseStockInspect() {
	for _, e := range m.DecreaseStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.DecreaseStock with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecreaseStockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecreaseStockCounter) < 1 {
		if m.DecreaseStockMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.DecreaseStock")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.DecreaseStock with params: %#v", *m.DecreaseStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecreaseStock != nil && mm_atomic.LoadUint64(&m.afterDecreaseStockCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.DecreaseStock")
	}
}

type mLOMSRepoMockGetStocks struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockGetStocksExpectation
	expectations       []*LOMSRepoMockGetStocksExpectation

	callArgs []*LOMSRepoMockGetStocksParams
	mutex    sync.RWMutex
}

// LOMSRepoMockGetStocksExpectation specifies expectation struct of the LOMSRepo.GetStocks
type LOMSRepoMockGetStocksExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockGetStocksParams
	results *LOMSRepoMockGetStocksResults
	Counter uint64
}

// LOMSRepoMockGetStocksParams contains parameters of the LOMSRepo.GetStocks
type LOMSRepoMockGetStocksParams struct {
	ctx context.Context
	sku uint32
}

// LOMSRepoMockGetStocksResults contains results of the LOMSRepo.GetStocks
type LOMSRepoMockGetStocksResults struct {
	sa1 []model.Stock
	err error
}

// Expect sets up expected params for LOMSRepo.GetStocks
func (mmGetStocks *mLOMSRepoMockGetStocks) Expect(ctx context.Context, sku uint32) *mLOMSRepoMockGetStocks {
	if mmGetStocks.mock.funcGetStocks != nil {
		mmGetStocks.mock.t.Fatalf("LOMSRepoMock.GetStocks mock is already set by Set")
	}

	if mmGetStocks.defaultExpectation == nil {
		mmGetStocks.defaultExpectation = &LOMSRepoMockGetStocksExpectation{}
	}

	mmGetStocks.defaultExpectation.params = &LOMSRepoMockGetStocksParams{ctx, sku}
	for _, e := range mmGetStocks.expectations {
		if minimock.Equal(e.params, mmGetStocks.defaultExpectation.params) {
			mmGetStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStocks.defaultExpectation.params)
		}
	}

	return mmGetStocks
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.GetStocks
func (mmGetStocks *mLOMSRepoMockGetStocks) Inspect(f func(ctx context.Context, sku uint32)) *mLOMSRepoMockGetStocks {
	if mmGetStocks.mock.inspectFuncGetStocks != nil {
		mmGetStocks.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.GetStocks")
	}

	mmGetStocks.mock.inspectFuncGetStocks = f

	return mmGetStocks
}

// Return sets up results that will be returned by LOMSRepo.GetStocks
func (mmGetStocks *mLOMSRepoMockGetStocks) Return(sa1 []model.Stock, err error) *LOMSRepoMock {
	if mmGetStocks.mock.funcGetStocks != nil {
		mmGetStocks.mock.t.Fatalf("LOMSRepoMock.GetStocks mock is already set by Set")
	}

	if mmGetStocks.defaultExpectation == nil {
		mmGetStocks.defaultExpectation = &LOMSRepoMockGetStocksExpectation{mock: mmGetStocks.mock}
	}
	mmGetStocks.defaultExpectation.results = &LOMSRepoMockGetStocksResults{sa1, err}
	return mmGetStocks.mock
}

// Set uses given function f to mock the LOMSRepo.GetStocks method
func (mmGetStocks *mLOMSRepoMockGetStocks) Set(f func(ctx context.Context, sku uint32) (sa1 []model.Stock, err error)) *LOMSRepoMock {
	if mmGetStocks.defaultExpectation != nil {
		mmGetStocks.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.GetStocks method")
	}

	if len(mmGetStocks.expectations) > 0 {
		mmGetStocks.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.GetStocks method")
	}

	mmGetStocks.mock.funcGetStocks = f
	return mmGetStocks.mock
}

// When sets expectation for the LOMSRepo.GetStocks which will trigger the result defined by the following
// Then helper
func (mmGetStocks *mLOMSRepoMockGetStocks) When(ctx context.Context, sku uint32) *LOMSRepoMockGetStocksExpectation {
	if mmGetStocks.mock.funcGetStocks != nil {
		mmGetStocks.mock.t.Fatalf("LOMSRepoMock.GetStocks mock is already set by Set")
	}

	expectation := &LOMSRepoMockGetStocksExpectation{
		mock:   mmGetStocks.mock,
		params: &LOMSRepoMockGetStocksParams{ctx, sku},
	}
	mmGetStocks.expectations = append(mmGetStocks.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.GetStocks return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockGetStocksExpectation) Then(sa1 []model.Stock, err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockGetStocksResults{sa1, err}
	return e.mock
}

// GetStocks implements domain.LOMSRepo
func (mmGetStocks *LOMSRepoMock) GetStocks(ctx context.Context, sku uint32) (sa1 []model.Stock, err error) {
	mm_atomic.AddUint64(&mmGetStocks.beforeGetStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStocks.afterGetStocksCounter, 1)

	if mmGetStocks.inspectFuncGetStocks != nil {
		mmGetStocks.inspectFuncGetStocks(ctx, sku)
	}

	mm_params := &LOMSRepoMockGetStocksParams{ctx, sku}

	// Record call args
	mmGetStocks.GetStocksMock.mutex.Lock()
	mmGetStocks.GetStocksMock.callArgs = append(mmGetStocks.GetStocksMock.callArgs, mm_params)
	mmGetStocks.GetStocksMock.mutex.Unlock()

	for _, e := range mmGetStocks.GetStocksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetStocks.GetStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStocks.GetStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStocks.GetStocksMock.defaultExpectation.params
		mm_got := LOMSRepoMockGetStocksParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStocks.t.Errorf("LOMSRepoMock.GetStocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStocks.GetStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStocks.t.Fatal("No results are set for the LOMSRepoMock.GetStocks")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetStocks.funcGetStocks != nil {
		return mmGetStocks.funcGetStocks(ctx, sku)
	}
	mmGetStocks.t.Fatalf("Unexpected call to LOMSRepoMock.GetStocks. %v %v", ctx, sku)
	return
}

// GetStocksAfterCounter returns a count of finished LOMSRepoMock.GetStocks invocations
func (mmGetStocks *LOMSRepoMock) GetStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocks.afterGetStocksCounter)
}

// GetStocksBeforeCounter returns a count of LOMSRepoMock.GetStocks invocations
func (mmGetStocks *LOMSRepoMock) GetStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocks.beforeGetStocksCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.GetStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStocks *mLOMSRepoMockGetStocks) Calls() []*LOMSRepoMockGetStocksParams {
	mmGetStocks.mutex.RLock()

	argCopy := make([]*LOMSRepoMockGetStocksParams, len(mmGetStocks.callArgs))
	copy(argCopy, mmGetStocks.callArgs)

	mmGetStocks.mutex.RUnlock()

	return argCopy
}

// MinimockGetStocksDone returns true if the count of the GetStocks invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockGetStocksDone() bool {
	for _, e := range m.GetStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStocksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStocks != nil && mm_atomic.LoadUint64(&m.afterGetStocksCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStocksInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockGetStocksInspect() {
	for _, e := range m.GetStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.GetStocks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStocksCounter) < 1 {
		if m.GetStocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.GetStocks")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.GetStocks with params: %#v", *m.GetStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStocks != nil && mm_atomic.LoadUint64(&m.afterGetStocksCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.GetStocks")
	}
}

type mLOMSRepoMockIncreaseStock struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockIncreaseStockExpectation
	expectations       []*LOMSRepoMockIncreaseStockExpectation

	callArgs []*LOMSRepoMockIncreaseStockParams
	mutex    sync.RWMutex
}

// LOMSRepoMockIncreaseStockExpectation specifies expectation struct of the LOMSRepo.IncreaseStock
type LOMSRepoMockIncreaseStockExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockIncreaseStockParams
	results *LOMSRepoMockIncreaseStockResults
	Counter uint64
}

// LOMSRepoMockIncreaseStockParams contains parameters of the LOMSRepo.IncreaseStock
type LOMSRepoMockIncreaseStockParams struct {
	ctx   context.Context
	sku   int64
	stock model.Stock
}

// LOMSRepoMockIncreaseStockResults contains results of the LOMSRepo.IncreaseStock
type LOMSRepoMockIncreaseStockResults struct {
	err error
}

// Expect sets up expected params for LOMSRepo.IncreaseStock
func (mmIncreaseStock *mLOMSRepoMockIncreaseStock) Expect(ctx context.Context, sku int64, stock model.Stock) *mLOMSRepoMockIncreaseStock {
	if mmIncreaseStock.mock.funcIncreaseStock != nil {
		mmIncreaseStock.mock.t.Fatalf("LOMSRepoMock.IncreaseStock mock is already set by Set")
	}

	if mmIncreaseStock.defaultExpectation == nil {
		mmIncreaseStock.defaultExpectation = &LOMSRepoMockIncreaseStockExpectation{}
	}

	mmIncreaseStock.defaultExpectation.params = &LOMSRepoMockIncreaseStockParams{ctx, sku, stock}
	for _, e := range mmIncreaseStock.expectations {
		if minimock.Equal(e.params, mmIncreaseStock.defaultExpectation.params) {
			mmIncreaseStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIncreaseStock.defaultExpectation.params)
		}
	}

	return mmIncreaseStock
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.IncreaseStock
func (mmIncreaseStock *mLOMSRepoMockIncreaseStock) Inspect(f func(ctx context.Context, sku int64, stock model.Stock)) *mLOMSRepoMockIncreaseStock {
	if mmIncreaseStock.mock.inspectFuncIncreaseStock != nil {
		mmIncreaseStock.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.IncreaseStock")
	}

	mmIncreaseStock.mock.inspectFuncIncreaseStock = f

	return mmIncreaseStock
}

// Return sets up results that will be returned by LOMSRepo.IncreaseStock
func (mmIncreaseStock *mLOMSRepoMockIncreaseStock) Return(err error) *LOMSRepoMock {
	if mmIncreaseStock.mock.funcIncreaseStock != nil {
		mmIncreaseStock.mock.t.Fatalf("LOMSRepoMock.IncreaseStock mock is already set by Set")
	}

	if mmIncreaseStock.defaultExpectation == nil {
		mmIncreaseStock.defaultExpectation = &LOMSRepoMockIncreaseStockExpectation{mock: mmIncreaseStock.mock}
	}
	mmIncreaseStock.defaultExpectation.results = &LOMSRepoMockIncreaseStockResults{err}
	return mmIncreaseStock.mock
}

// Set uses given function f to mock the LOMSRepo.IncreaseStock method
func (mmIncreaseStock *mLOMSRepoMockIncreaseStock) Set(f func(ctx context.Context, sku int64, stock model.Stock) (err error)) *LOMSRepoMock {
	if mmIncreaseStock.defaultExpectation != nil {
		mmIncreaseStock.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.IncreaseStock method")
	}

	if len(mmIncreaseStock.expectations) > 0 {
		mmIncreaseStock.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.IncreaseStock method")
	}

	mmIncreaseStock.mock.funcIncreaseStock = f
	return mmIncreaseStock.mock
}

// When sets expectation for the LOMSRepo.IncreaseStock which will trigger the result defined by the following
// Then helper
func (mmIncreaseStock *mLOMSRepoMockIncreaseStock) When(ctx context.Context, sku int64, stock model.Stock) *LOMSRepoMockIncreaseStockExpectation {
	if mmIncreaseStock.mock.funcIncreaseStock != nil {
		mmIncreaseStock.mock.t.Fatalf("LOMSRepoMock.IncreaseStock mock is already set by Set")
	}

	expectation := &LOMSRepoMockIncreaseStockExpectation{
		mock:   mmIncreaseStock.mock,
		params: &LOMSRepoMockIncreaseStockParams{ctx, sku, stock},
	}
	mmIncreaseStock.expectations = append(mmIncreaseStock.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.IncreaseStock return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockIncreaseStockExpectation) Then(err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockIncreaseStockResults{err}
	return e.mock
}

// IncreaseStock implements domain.LOMSRepo
func (mmIncreaseStock *LOMSRepoMock) IncreaseStock(ctx context.Context, sku int64, stock model.Stock) (err error) {
	mm_atomic.AddUint64(&mmIncreaseStock.beforeIncreaseStockCounter, 1)
	defer mm_atomic.AddUint64(&mmIncreaseStock.afterIncreaseStockCounter, 1)

	if mmIncreaseStock.inspectFuncIncreaseStock != nil {
		mmIncreaseStock.inspectFuncIncreaseStock(ctx, sku, stock)
	}

	mm_params := &LOMSRepoMockIncreaseStockParams{ctx, sku, stock}

	// Record call args
	mmIncreaseStock.IncreaseStockMock.mutex.Lock()
	mmIncreaseStock.IncreaseStockMock.callArgs = append(mmIncreaseStock.IncreaseStockMock.callArgs, mm_params)
	mmIncreaseStock.IncreaseStockMock.mutex.Unlock()

	for _, e := range mmIncreaseStock.IncreaseStockMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmIncreaseStock.IncreaseStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncreaseStock.IncreaseStockMock.defaultExpectation.Counter, 1)
		mm_want := mmIncreaseStock.IncreaseStockMock.defaultExpectation.params
		mm_got := LOMSRepoMockIncreaseStockParams{ctx, sku, stock}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIncreaseStock.t.Errorf("LOMSRepoMock.IncreaseStock got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIncreaseStock.IncreaseStockMock.defaultExpectation.results
		if mm_results == nil {
			mmIncreaseStock.t.Fatal("No results are set for the LOMSRepoMock.IncreaseStock")
		}
		return (*mm_results).err
	}
	if mmIncreaseStock.funcIncreaseStock != nil {
		return mmIncreaseStock.funcIncreaseStock(ctx, sku, stock)
	}
	mmIncreaseStock.t.Fatalf("Unexpected call to LOMSRepoMock.IncreaseStock. %v %v %v", ctx, sku, stock)
	return
}

// IncreaseStockAfterCounter returns a count of finished LOMSRepoMock.IncreaseStock invocations
func (mmIncreaseStock *LOMSRepoMock) IncreaseStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseStock.afterIncreaseStockCounter)
}

// IncreaseStockBeforeCounter returns a count of LOMSRepoMock.IncreaseStock invocations
func (mmIncreaseStock *LOMSRepoMock) IncreaseStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseStock.beforeIncreaseStockCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.IncreaseStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIncreaseStock *mLOMSRepoMockIncreaseStock) Calls() []*LOMSRepoMockIncreaseStockParams {
	mmIncreaseStock.mutex.RLock()

	argCopy := make([]*LOMSRepoMockIncreaseStockParams, len(mmIncreaseStock.callArgs))
	copy(argCopy, mmIncreaseStock.callArgs)

	mmIncreaseStock.mutex.RUnlock()

	return argCopy
}

// MinimockIncreaseStockDone returns true if the count of the IncreaseStock invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockIncreaseStockDone() bool {
	for _, e := range m.IncreaseStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IncreaseStockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIncreaseStockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncreaseStock != nil && mm_atomic.LoadUint64(&m.afterIncreaseStockCounter) < 1 {
		return false
	}
	return true
}

// MinimockIncreaseStockInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockIncreaseStockInspect() {
	for _, e := range m.IncreaseStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.IncreaseStock with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IncreaseStockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIncreaseStockCounter) < 1 {
		if m.IncreaseStockMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.IncreaseStock")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.IncreaseStock with params: %#v", *m.IncreaseStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncreaseStock != nil && mm_atomic.LoadUint64(&m.afterIncreaseStockCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.IncreaseStock")
	}
}

type mLOMSRepoMockInsertOrderInfo struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockInsertOrderInfoExpectation
	expectations       []*LOMSRepoMockInsertOrderInfoExpectation

	callArgs []*LOMSRepoMockInsertOrderInfoParams
	mutex    sync.RWMutex
}

// LOMSRepoMockInsertOrderInfoExpectation specifies expectation struct of the LOMSRepo.InsertOrderInfo
type LOMSRepoMockInsertOrderInfoExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockInsertOrderInfoParams
	results *LOMSRepoMockInsertOrderInfoResults
	Counter uint64
}

// LOMSRepoMockInsertOrderInfoParams contains parameters of the LOMSRepo.InsertOrderInfo
type LOMSRepoMockInsertOrderInfoParams struct {
	ctx   context.Context
	order model.Order
}

// LOMSRepoMockInsertOrderInfoResults contains results of the LOMSRepo.InsertOrderInfo
type LOMSRepoMockInsertOrderInfoResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for LOMSRepo.InsertOrderInfo
func (mmInsertOrderInfo *mLOMSRepoMockInsertOrderInfo) Expect(ctx context.Context, order model.Order) *mLOMSRepoMockInsertOrderInfo {
	if mmInsertOrderInfo.mock.funcInsertOrderInfo != nil {
		mmInsertOrderInfo.mock.t.Fatalf("LOMSRepoMock.InsertOrderInfo mock is already set by Set")
	}

	if mmInsertOrderInfo.defaultExpectation == nil {
		mmInsertOrderInfo.defaultExpectation = &LOMSRepoMockInsertOrderInfoExpectation{}
	}

	mmInsertOrderInfo.defaultExpectation.params = &LOMSRepoMockInsertOrderInfoParams{ctx, order}
	for _, e := range mmInsertOrderInfo.expectations {
		if minimock.Equal(e.params, mmInsertOrderInfo.defaultExpectation.params) {
			mmInsertOrderInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertOrderInfo.defaultExpectation.params)
		}
	}

	return mmInsertOrderInfo
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.InsertOrderInfo
func (mmInsertOrderInfo *mLOMSRepoMockInsertOrderInfo) Inspect(f func(ctx context.Context, order model.Order)) *mLOMSRepoMockInsertOrderInfo {
	if mmInsertOrderInfo.mock.inspectFuncInsertOrderInfo != nil {
		mmInsertOrderInfo.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.InsertOrderInfo")
	}

	mmInsertOrderInfo.mock.inspectFuncInsertOrderInfo = f

	return mmInsertOrderInfo
}

// Return sets up results that will be returned by LOMSRepo.InsertOrderInfo
func (mmInsertOrderInfo *mLOMSRepoMockInsertOrderInfo) Return(i1 int64, err error) *LOMSRepoMock {
	if mmInsertOrderInfo.mock.funcInsertOrderInfo != nil {
		mmInsertOrderInfo.mock.t.Fatalf("LOMSRepoMock.InsertOrderInfo mock is already set by Set")
	}

	if mmInsertOrderInfo.defaultExpectation == nil {
		mmInsertOrderInfo.defaultExpectation = &LOMSRepoMockInsertOrderInfoExpectation{mock: mmInsertOrderInfo.mock}
	}
	mmInsertOrderInfo.defaultExpectation.results = &LOMSRepoMockInsertOrderInfoResults{i1, err}
	return mmInsertOrderInfo.mock
}

// Set uses given function f to mock the LOMSRepo.InsertOrderInfo method
func (mmInsertOrderInfo *mLOMSRepoMockInsertOrderInfo) Set(f func(ctx context.Context, order model.Order) (i1 int64, err error)) *LOMSRepoMock {
	if mmInsertOrderInfo.defaultExpectation != nil {
		mmInsertOrderInfo.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.InsertOrderInfo method")
	}

	if len(mmInsertOrderInfo.expectations) > 0 {
		mmInsertOrderInfo.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.InsertOrderInfo method")
	}

	mmInsertOrderInfo.mock.funcInsertOrderInfo = f
	return mmInsertOrderInfo.mock
}

// When sets expectation for the LOMSRepo.InsertOrderInfo which will trigger the result defined by the following
// Then helper
func (mmInsertOrderInfo *mLOMSRepoMockInsertOrderInfo) When(ctx context.Context, order model.Order) *LOMSRepoMockInsertOrderInfoExpectation {
	if mmInsertOrderInfo.mock.funcInsertOrderInfo != nil {
		mmInsertOrderInfo.mock.t.Fatalf("LOMSRepoMock.InsertOrderInfo mock is already set by Set")
	}

	expectation := &LOMSRepoMockInsertOrderInfoExpectation{
		mock:   mmInsertOrderInfo.mock,
		params: &LOMSRepoMockInsertOrderInfoParams{ctx, order},
	}
	mmInsertOrderInfo.expectations = append(mmInsertOrderInfo.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.InsertOrderInfo return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockInsertOrderInfoExpectation) Then(i1 int64, err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockInsertOrderInfoResults{i1, err}
	return e.mock
}

// InsertOrderInfo implements domain.LOMSRepo
func (mmInsertOrderInfo *LOMSRepoMock) InsertOrderInfo(ctx context.Context, order model.Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmInsertOrderInfo.beforeInsertOrderInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertOrderInfo.afterInsertOrderInfoCounter, 1)

	if mmInsertOrderInfo.inspectFuncInsertOrderInfo != nil {
		mmInsertOrderInfo.inspectFuncInsertOrderInfo(ctx, order)
	}

	mm_params := &LOMSRepoMockInsertOrderInfoParams{ctx, order}

	// Record call args
	mmInsertOrderInfo.InsertOrderInfoMock.mutex.Lock()
	mmInsertOrderInfo.InsertOrderInfoMock.callArgs = append(mmInsertOrderInfo.InsertOrderInfoMock.callArgs, mm_params)
	mmInsertOrderInfo.InsertOrderInfoMock.mutex.Unlock()

	for _, e := range mmInsertOrderInfo.InsertOrderInfoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmInsertOrderInfo.InsertOrderInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertOrderInfo.InsertOrderInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertOrderInfo.InsertOrderInfoMock.defaultExpectation.params
		mm_got := LOMSRepoMockInsertOrderInfoParams{ctx, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertOrderInfo.t.Errorf("LOMSRepoMock.InsertOrderInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertOrderInfo.InsertOrderInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertOrderInfo.t.Fatal("No results are set for the LOMSRepoMock.InsertOrderInfo")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmInsertOrderInfo.funcInsertOrderInfo != nil {
		return mmInsertOrderInfo.funcInsertOrderInfo(ctx, order)
	}
	mmInsertOrderInfo.t.Fatalf("Unexpected call to LOMSRepoMock.InsertOrderInfo. %v %v", ctx, order)
	return
}

// InsertOrderInfoAfterCounter returns a count of finished LOMSRepoMock.InsertOrderInfo invocations
func (mmInsertOrderInfo *LOMSRepoMock) InsertOrderInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertOrderInfo.afterInsertOrderInfoCounter)
}

// InsertOrderInfoBeforeCounter returns a count of LOMSRepoMock.InsertOrderInfo invocations
func (mmInsertOrderInfo *LOMSRepoMock) InsertOrderInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertOrderInfo.beforeInsertOrderInfoCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.InsertOrderInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertOrderInfo *mLOMSRepoMockInsertOrderInfo) Calls() []*LOMSRepoMockInsertOrderInfoParams {
	mmInsertOrderInfo.mutex.RLock()

	argCopy := make([]*LOMSRepoMockInsertOrderInfoParams, len(mmInsertOrderInfo.callArgs))
	copy(argCopy, mmInsertOrderInfo.callArgs)

	mmInsertOrderInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInsertOrderInfoDone returns true if the count of the InsertOrderInfo invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockInsertOrderInfoDone() bool {
	for _, e := range m.InsertOrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertOrderInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertOrderInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertOrderInfo != nil && mm_atomic.LoadUint64(&m.afterInsertOrderInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertOrderInfoInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockInsertOrderInfoInspect() {
	for _, e := range m.InsertOrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.InsertOrderInfo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertOrderInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertOrderInfoCounter) < 1 {
		if m.InsertOrderInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.InsertOrderInfo")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.InsertOrderInfo with params: %#v", *m.InsertOrderInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertOrderInfo != nil && mm_atomic.LoadUint64(&m.afterInsertOrderInfoCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.InsertOrderInfo")
	}
}

type mLOMSRepoMockInsertOrderItems struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockInsertOrderItemsExpectation
	expectations       []*LOMSRepoMockInsertOrderItemsExpectation

	callArgs []*LOMSRepoMockInsertOrderItemsParams
	mutex    sync.RWMutex
}

// LOMSRepoMockInsertOrderItemsExpectation specifies expectation struct of the LOMSRepo.InsertOrderItems
type LOMSRepoMockInsertOrderItemsExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockInsertOrderItemsParams
	results *LOMSRepoMockInsertOrderItemsResults
	Counter uint64
}

// LOMSRepoMockInsertOrderItemsParams contains parameters of the LOMSRepo.InsertOrderItems
type LOMSRepoMockInsertOrderItemsParams struct {
	ctx         context.Context
	orderID     int64
	domainItems []model.Item
}

// LOMSRepoMockInsertOrderItemsResults contains results of the LOMSRepo.InsertOrderItems
type LOMSRepoMockInsertOrderItemsResults struct {
	err error
}

// Expect sets up expected params for LOMSRepo.InsertOrderItems
func (mmInsertOrderItems *mLOMSRepoMockInsertOrderItems) Expect(ctx context.Context, orderID int64, domainItems []model.Item) *mLOMSRepoMockInsertOrderItems {
	if mmInsertOrderItems.mock.funcInsertOrderItems != nil {
		mmInsertOrderItems.mock.t.Fatalf("LOMSRepoMock.InsertOrderItems mock is already set by Set")
	}

	if mmInsertOrderItems.defaultExpectation == nil {
		mmInsertOrderItems.defaultExpectation = &LOMSRepoMockInsertOrderItemsExpectation{}
	}

	mmInsertOrderItems.defaultExpectation.params = &LOMSRepoMockInsertOrderItemsParams{ctx, orderID, domainItems}
	for _, e := range mmInsertOrderItems.expectations {
		if minimock.Equal(e.params, mmInsertOrderItems.defaultExpectation.params) {
			mmInsertOrderItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertOrderItems.defaultExpectation.params)
		}
	}

	return mmInsertOrderItems
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.InsertOrderItems
func (mmInsertOrderItems *mLOMSRepoMockInsertOrderItems) Inspect(f func(ctx context.Context, orderID int64, domainItems []model.Item)) *mLOMSRepoMockInsertOrderItems {
	if mmInsertOrderItems.mock.inspectFuncInsertOrderItems != nil {
		mmInsertOrderItems.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.InsertOrderItems")
	}

	mmInsertOrderItems.mock.inspectFuncInsertOrderItems = f

	return mmInsertOrderItems
}

// Return sets up results that will be returned by LOMSRepo.InsertOrderItems
func (mmInsertOrderItems *mLOMSRepoMockInsertOrderItems) Return(err error) *LOMSRepoMock {
	if mmInsertOrderItems.mock.funcInsertOrderItems != nil {
		mmInsertOrderItems.mock.t.Fatalf("LOMSRepoMock.InsertOrderItems mock is already set by Set")
	}

	if mmInsertOrderItems.defaultExpectation == nil {
		mmInsertOrderItems.defaultExpectation = &LOMSRepoMockInsertOrderItemsExpectation{mock: mmInsertOrderItems.mock}
	}
	mmInsertOrderItems.defaultExpectation.results = &LOMSRepoMockInsertOrderItemsResults{err}
	return mmInsertOrderItems.mock
}

// Set uses given function f to mock the LOMSRepo.InsertOrderItems method
func (mmInsertOrderItems *mLOMSRepoMockInsertOrderItems) Set(f func(ctx context.Context, orderID int64, domainItems []model.Item) (err error)) *LOMSRepoMock {
	if mmInsertOrderItems.defaultExpectation != nil {
		mmInsertOrderItems.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.InsertOrderItems method")
	}

	if len(mmInsertOrderItems.expectations) > 0 {
		mmInsertOrderItems.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.InsertOrderItems method")
	}

	mmInsertOrderItems.mock.funcInsertOrderItems = f
	return mmInsertOrderItems.mock
}

// When sets expectation for the LOMSRepo.InsertOrderItems which will trigger the result defined by the following
// Then helper
func (mmInsertOrderItems *mLOMSRepoMockInsertOrderItems) When(ctx context.Context, orderID int64, domainItems []model.Item) *LOMSRepoMockInsertOrderItemsExpectation {
	if mmInsertOrderItems.mock.funcInsertOrderItems != nil {
		mmInsertOrderItems.mock.t.Fatalf("LOMSRepoMock.InsertOrderItems mock is already set by Set")
	}

	expectation := &LOMSRepoMockInsertOrderItemsExpectation{
		mock:   mmInsertOrderItems.mock,
		params: &LOMSRepoMockInsertOrderItemsParams{ctx, orderID, domainItems},
	}
	mmInsertOrderItems.expectations = append(mmInsertOrderItems.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.InsertOrderItems return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockInsertOrderItemsExpectation) Then(err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockInsertOrderItemsResults{err}
	return e.mock
}

// InsertOrderItems implements domain.LOMSRepo
func (mmInsertOrderItems *LOMSRepoMock) InsertOrderItems(ctx context.Context, orderID int64, domainItems []model.Item) (err error) {
	mm_atomic.AddUint64(&mmInsertOrderItems.beforeInsertOrderItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertOrderItems.afterInsertOrderItemsCounter, 1)

	if mmInsertOrderItems.inspectFuncInsertOrderItems != nil {
		mmInsertOrderItems.inspectFuncInsertOrderItems(ctx, orderID, domainItems)
	}

	mm_params := &LOMSRepoMockInsertOrderItemsParams{ctx, orderID, domainItems}

	// Record call args
	mmInsertOrderItems.InsertOrderItemsMock.mutex.Lock()
	mmInsertOrderItems.InsertOrderItemsMock.callArgs = append(mmInsertOrderItems.InsertOrderItemsMock.callArgs, mm_params)
	mmInsertOrderItems.InsertOrderItemsMock.mutex.Unlock()

	for _, e := range mmInsertOrderItems.InsertOrderItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertOrderItems.InsertOrderItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertOrderItems.InsertOrderItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertOrderItems.InsertOrderItemsMock.defaultExpectation.params
		mm_got := LOMSRepoMockInsertOrderItemsParams{ctx, orderID, domainItems}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertOrderItems.t.Errorf("LOMSRepoMock.InsertOrderItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertOrderItems.InsertOrderItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertOrderItems.t.Fatal("No results are set for the LOMSRepoMock.InsertOrderItems")
		}
		return (*mm_results).err
	}
	if mmInsertOrderItems.funcInsertOrderItems != nil {
		return mmInsertOrderItems.funcInsertOrderItems(ctx, orderID, domainItems)
	}
	mmInsertOrderItems.t.Fatalf("Unexpected call to LOMSRepoMock.InsertOrderItems. %v %v %v", ctx, orderID, domainItems)
	return
}

// InsertOrderItemsAfterCounter returns a count of finished LOMSRepoMock.InsertOrderItems invocations
func (mmInsertOrderItems *LOMSRepoMock) InsertOrderItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertOrderItems.afterInsertOrderItemsCounter)
}

// InsertOrderItemsBeforeCounter returns a count of LOMSRepoMock.InsertOrderItems invocations
func (mmInsertOrderItems *LOMSRepoMock) InsertOrderItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertOrderItems.beforeInsertOrderItemsCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.InsertOrderItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertOrderItems *mLOMSRepoMockInsertOrderItems) Calls() []*LOMSRepoMockInsertOrderItemsParams {
	mmInsertOrderItems.mutex.RLock()

	argCopy := make([]*LOMSRepoMockInsertOrderItemsParams, len(mmInsertOrderItems.callArgs))
	copy(argCopy, mmInsertOrderItems.callArgs)

	mmInsertOrderItems.mutex.RUnlock()

	return argCopy
}

// MinimockInsertOrderItemsDone returns true if the count of the InsertOrderItems invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockInsertOrderItemsDone() bool {
	for _, e := range m.InsertOrderItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertOrderItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertOrderItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertOrderItems != nil && mm_atomic.LoadUint64(&m.afterInsertOrderItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertOrderItemsInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockInsertOrderItemsInspect() {
	for _, e := range m.InsertOrderItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.InsertOrderItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertOrderItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertOrderItemsCounter) < 1 {
		if m.InsertOrderItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.InsertOrderItems")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.InsertOrderItems with params: %#v", *m.InsertOrderItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertOrderItems != nil && mm_atomic.LoadUint64(&m.afterInsertOrderItemsCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.InsertOrderItems")
	}
}

type mLOMSRepoMockListOrderInfo struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockListOrderInfoExpectation
	expectations       []*LOMSRepoMockListOrderInfoExpectation

	callArgs []*LOMSRepoMockListOrderInfoParams
	mutex    sync.RWMutex
}

// LOMSRepoMockListOrderInfoExpectation specifies expectation struct of the LOMSRepo.ListOrderInfo
type LOMSRepoMockListOrderInfoExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockListOrderInfoParams
	results *LOMSRepoMockListOrderInfoResults
	Counter uint64
}

// LOMSRepoMockListOrderInfoParams contains parameters of the LOMSRepo.ListOrderInfo
type LOMSRepoMockListOrderInfoParams struct {
	ctx     context.Context
	orderID int64
}

// LOMSRepoMockListOrderInfoResults contains results of the LOMSRepo.ListOrderInfo
type LOMSRepoMockListOrderInfoResults struct {
	o1  model.Order
	err error
}

// Expect sets up expected params for LOMSRepo.ListOrderInfo
func (mmListOrderInfo *mLOMSRepoMockListOrderInfo) Expect(ctx context.Context, orderID int64) *mLOMSRepoMockListOrderInfo {
	if mmListOrderInfo.mock.funcListOrderInfo != nil {
		mmListOrderInfo.mock.t.Fatalf("LOMSRepoMock.ListOrderInfo mock is already set by Set")
	}

	if mmListOrderInfo.defaultExpectation == nil {
		mmListOrderInfo.defaultExpectation = &LOMSRepoMockListOrderInfoExpectation{}
	}

	mmListOrderInfo.defaultExpectation.params = &LOMSRepoMockListOrderInfoParams{ctx, orderID}
	for _, e := range mmListOrderInfo.expectations {
		if minimock.Equal(e.params, mmListOrderInfo.defaultExpectation.params) {
			mmListOrderInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrderInfo.defaultExpectation.params)
		}
	}

	return mmListOrderInfo
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.ListOrderInfo
func (mmListOrderInfo *mLOMSRepoMockListOrderInfo) Inspect(f func(ctx context.Context, orderID int64)) *mLOMSRepoMockListOrderInfo {
	if mmListOrderInfo.mock.inspectFuncListOrderInfo != nil {
		mmListOrderInfo.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.ListOrderInfo")
	}

	mmListOrderInfo.mock.inspectFuncListOrderInfo = f

	return mmListOrderInfo
}

// Return sets up results that will be returned by LOMSRepo.ListOrderInfo
func (mmListOrderInfo *mLOMSRepoMockListOrderInfo) Return(o1 model.Order, err error) *LOMSRepoMock {
	if mmListOrderInfo.mock.funcListOrderInfo != nil {
		mmListOrderInfo.mock.t.Fatalf("LOMSRepoMock.ListOrderInfo mock is already set by Set")
	}

	if mmListOrderInfo.defaultExpectation == nil {
		mmListOrderInfo.defaultExpectation = &LOMSRepoMockListOrderInfoExpectation{mock: mmListOrderInfo.mock}
	}
	mmListOrderInfo.defaultExpectation.results = &LOMSRepoMockListOrderInfoResults{o1, err}
	return mmListOrderInfo.mock
}

// Set uses given function f to mock the LOMSRepo.ListOrderInfo method
func (mmListOrderInfo *mLOMSRepoMockListOrderInfo) Set(f func(ctx context.Context, orderID int64) (o1 model.Order, err error)) *LOMSRepoMock {
	if mmListOrderInfo.defaultExpectation != nil {
		mmListOrderInfo.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.ListOrderInfo method")
	}

	if len(mmListOrderInfo.expectations) > 0 {
		mmListOrderInfo.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.ListOrderInfo method")
	}

	mmListOrderInfo.mock.funcListOrderInfo = f
	return mmListOrderInfo.mock
}

// When sets expectation for the LOMSRepo.ListOrderInfo which will trigger the result defined by the following
// Then helper
func (mmListOrderInfo *mLOMSRepoMockListOrderInfo) When(ctx context.Context, orderID int64) *LOMSRepoMockListOrderInfoExpectation {
	if mmListOrderInfo.mock.funcListOrderInfo != nil {
		mmListOrderInfo.mock.t.Fatalf("LOMSRepoMock.ListOrderInfo mock is already set by Set")
	}

	expectation := &LOMSRepoMockListOrderInfoExpectation{
		mock:   mmListOrderInfo.mock,
		params: &LOMSRepoMockListOrderInfoParams{ctx, orderID},
	}
	mmListOrderInfo.expectations = append(mmListOrderInfo.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.ListOrderInfo return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockListOrderInfoExpectation) Then(o1 model.Order, err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockListOrderInfoResults{o1, err}
	return e.mock
}

// ListOrderInfo implements domain.LOMSRepo
func (mmListOrderInfo *LOMSRepoMock) ListOrderInfo(ctx context.Context, orderID int64) (o1 model.Order, err error) {
	mm_atomic.AddUint64(&mmListOrderInfo.beforeListOrderInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrderInfo.afterListOrderInfoCounter, 1)

	if mmListOrderInfo.inspectFuncListOrderInfo != nil {
		mmListOrderInfo.inspectFuncListOrderInfo(ctx, orderID)
	}

	mm_params := &LOMSRepoMockListOrderInfoParams{ctx, orderID}

	// Record call args
	mmListOrderInfo.ListOrderInfoMock.mutex.Lock()
	mmListOrderInfo.ListOrderInfoMock.callArgs = append(mmListOrderInfo.ListOrderInfoMock.callArgs, mm_params)
	mmListOrderInfo.ListOrderInfoMock.mutex.Unlock()

	for _, e := range mmListOrderInfo.ListOrderInfoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmListOrderInfo.ListOrderInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrderInfo.ListOrderInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrderInfo.ListOrderInfoMock.defaultExpectation.params
		mm_got := LOMSRepoMockListOrderInfoParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrderInfo.t.Errorf("LOMSRepoMock.ListOrderInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrderInfo.ListOrderInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrderInfo.t.Fatal("No results are set for the LOMSRepoMock.ListOrderInfo")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmListOrderInfo.funcListOrderInfo != nil {
		return mmListOrderInfo.funcListOrderInfo(ctx, orderID)
	}
	mmListOrderInfo.t.Fatalf("Unexpected call to LOMSRepoMock.ListOrderInfo. %v %v", ctx, orderID)
	return
}

// ListOrderInfoAfterCounter returns a count of finished LOMSRepoMock.ListOrderInfo invocations
func (mmListOrderInfo *LOMSRepoMock) ListOrderInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrderInfo.afterListOrderInfoCounter)
}

// ListOrderInfoBeforeCounter returns a count of LOMSRepoMock.ListOrderInfo invocations
func (mmListOrderInfo *LOMSRepoMock) ListOrderInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrderInfo.beforeListOrderInfoCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.ListOrderInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrderInfo *mLOMSRepoMockListOrderInfo) Calls() []*LOMSRepoMockListOrderInfoParams {
	mmListOrderInfo.mutex.RLock()

	argCopy := make([]*LOMSRepoMockListOrderInfoParams, len(mmListOrderInfo.callArgs))
	copy(argCopy, mmListOrderInfo.callArgs)

	mmListOrderInfo.mutex.RUnlock()

	return argCopy
}

// MinimockListOrderInfoDone returns true if the count of the ListOrderInfo invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockListOrderInfoDone() bool {
	for _, e := range m.ListOrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrderInfo != nil && mm_atomic.LoadUint64(&m.afterListOrderInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockListOrderInfoInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockListOrderInfoInspect() {
	for _, e := range m.ListOrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.ListOrderInfo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderInfoCounter) < 1 {
		if m.ListOrderInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.ListOrderInfo")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.ListOrderInfo with params: %#v", *m.ListOrderInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrderInfo != nil && mm_atomic.LoadUint64(&m.afterListOrderInfoCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.ListOrderInfo")
	}
}

type mLOMSRepoMockListOrderItems struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockListOrderItemsExpectation
	expectations       []*LOMSRepoMockListOrderItemsExpectation

	callArgs []*LOMSRepoMockListOrderItemsParams
	mutex    sync.RWMutex
}

// LOMSRepoMockListOrderItemsExpectation specifies expectation struct of the LOMSRepo.ListOrderItems
type LOMSRepoMockListOrderItemsExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockListOrderItemsParams
	results *LOMSRepoMockListOrderItemsResults
	Counter uint64
}

// LOMSRepoMockListOrderItemsParams contains parameters of the LOMSRepo.ListOrderItems
type LOMSRepoMockListOrderItemsParams struct {
	ctx     context.Context
	orderID int64
}

// LOMSRepoMockListOrderItemsResults contains results of the LOMSRepo.ListOrderItems
type LOMSRepoMockListOrderItemsResults struct {
	ia1 []model.Item
	err error
}

// Expect sets up expected params for LOMSRepo.ListOrderItems
func (mmListOrderItems *mLOMSRepoMockListOrderItems) Expect(ctx context.Context, orderID int64) *mLOMSRepoMockListOrderItems {
	if mmListOrderItems.mock.funcListOrderItems != nil {
		mmListOrderItems.mock.t.Fatalf("LOMSRepoMock.ListOrderItems mock is already set by Set")
	}

	if mmListOrderItems.defaultExpectation == nil {
		mmListOrderItems.defaultExpectation = &LOMSRepoMockListOrderItemsExpectation{}
	}

	mmListOrderItems.defaultExpectation.params = &LOMSRepoMockListOrderItemsParams{ctx, orderID}
	for _, e := range mmListOrderItems.expectations {
		if minimock.Equal(e.params, mmListOrderItems.defaultExpectation.params) {
			mmListOrderItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrderItems.defaultExpectation.params)
		}
	}

	return mmListOrderItems
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.ListOrderItems
func (mmListOrderItems *mLOMSRepoMockListOrderItems) Inspect(f func(ctx context.Context, orderID int64)) *mLOMSRepoMockListOrderItems {
	if mmListOrderItems.mock.inspectFuncListOrderItems != nil {
		mmListOrderItems.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.ListOrderItems")
	}

	mmListOrderItems.mock.inspectFuncListOrderItems = f

	return mmListOrderItems
}

// Return sets up results that will be returned by LOMSRepo.ListOrderItems
func (mmListOrderItems *mLOMSRepoMockListOrderItems) Return(ia1 []model.Item, err error) *LOMSRepoMock {
	if mmListOrderItems.mock.funcListOrderItems != nil {
		mmListOrderItems.mock.t.Fatalf("LOMSRepoMock.ListOrderItems mock is already set by Set")
	}

	if mmListOrderItems.defaultExpectation == nil {
		mmListOrderItems.defaultExpectation = &LOMSRepoMockListOrderItemsExpectation{mock: mmListOrderItems.mock}
	}
	mmListOrderItems.defaultExpectation.results = &LOMSRepoMockListOrderItemsResults{ia1, err}
	return mmListOrderItems.mock
}

// Set uses given function f to mock the LOMSRepo.ListOrderItems method
func (mmListOrderItems *mLOMSRepoMockListOrderItems) Set(f func(ctx context.Context, orderID int64) (ia1 []model.Item, err error)) *LOMSRepoMock {
	if mmListOrderItems.defaultExpectation != nil {
		mmListOrderItems.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.ListOrderItems method")
	}

	if len(mmListOrderItems.expectations) > 0 {
		mmListOrderItems.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.ListOrderItems method")
	}

	mmListOrderItems.mock.funcListOrderItems = f
	return mmListOrderItems.mock
}

// When sets expectation for the LOMSRepo.ListOrderItems which will trigger the result defined by the following
// Then helper
func (mmListOrderItems *mLOMSRepoMockListOrderItems) When(ctx context.Context, orderID int64) *LOMSRepoMockListOrderItemsExpectation {
	if mmListOrderItems.mock.funcListOrderItems != nil {
		mmListOrderItems.mock.t.Fatalf("LOMSRepoMock.ListOrderItems mock is already set by Set")
	}

	expectation := &LOMSRepoMockListOrderItemsExpectation{
		mock:   mmListOrderItems.mock,
		params: &LOMSRepoMockListOrderItemsParams{ctx, orderID},
	}
	mmListOrderItems.expectations = append(mmListOrderItems.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.ListOrderItems return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockListOrderItemsExpectation) Then(ia1 []model.Item, err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockListOrderItemsResults{ia1, err}
	return e.mock
}

// ListOrderItems implements domain.LOMSRepo
func (mmListOrderItems *LOMSRepoMock) ListOrderItems(ctx context.Context, orderID int64) (ia1 []model.Item, err error) {
	mm_atomic.AddUint64(&mmListOrderItems.beforeListOrderItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrderItems.afterListOrderItemsCounter, 1)

	if mmListOrderItems.inspectFuncListOrderItems != nil {
		mmListOrderItems.inspectFuncListOrderItems(ctx, orderID)
	}

	mm_params := &LOMSRepoMockListOrderItemsParams{ctx, orderID}

	// Record call args
	mmListOrderItems.ListOrderItemsMock.mutex.Lock()
	mmListOrderItems.ListOrderItemsMock.callArgs = append(mmListOrderItems.ListOrderItemsMock.callArgs, mm_params)
	mmListOrderItems.ListOrderItemsMock.mutex.Unlock()

	for _, e := range mmListOrderItems.ListOrderItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmListOrderItems.ListOrderItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrderItems.ListOrderItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrderItems.ListOrderItemsMock.defaultExpectation.params
		mm_got := LOMSRepoMockListOrderItemsParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrderItems.t.Errorf("LOMSRepoMock.ListOrderItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrderItems.ListOrderItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrderItems.t.Fatal("No results are set for the LOMSRepoMock.ListOrderItems")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmListOrderItems.funcListOrderItems != nil {
		return mmListOrderItems.funcListOrderItems(ctx, orderID)
	}
	mmListOrderItems.t.Fatalf("Unexpected call to LOMSRepoMock.ListOrderItems. %v %v", ctx, orderID)
	return
}

// ListOrderItemsAfterCounter returns a count of finished LOMSRepoMock.ListOrderItems invocations
func (mmListOrderItems *LOMSRepoMock) ListOrderItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrderItems.afterListOrderItemsCounter)
}

// ListOrderItemsBeforeCounter returns a count of LOMSRepoMock.ListOrderItems invocations
func (mmListOrderItems *LOMSRepoMock) ListOrderItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrderItems.beforeListOrderItemsCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.ListOrderItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrderItems *mLOMSRepoMockListOrderItems) Calls() []*LOMSRepoMockListOrderItemsParams {
	mmListOrderItems.mutex.RLock()

	argCopy := make([]*LOMSRepoMockListOrderItemsParams, len(mmListOrderItems.callArgs))
	copy(argCopy, mmListOrderItems.callArgs)

	mmListOrderItems.mutex.RUnlock()

	return argCopy
}

// MinimockListOrderItemsDone returns true if the count of the ListOrderItems invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockListOrderItemsDone() bool {
	for _, e := range m.ListOrderItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrderItems != nil && mm_atomic.LoadUint64(&m.afterListOrderItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListOrderItemsInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockListOrderItemsInspect() {
	for _, e := range m.ListOrderItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.ListOrderItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderItemsCounter) < 1 {
		if m.ListOrderItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.ListOrderItems")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.ListOrderItems with params: %#v", *m.ListOrderItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrderItems != nil && mm_atomic.LoadUint64(&m.afterListOrderItemsCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.ListOrderItems")
	}
}

type mLOMSRepoMockListUnpaidOrders struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockListUnpaidOrdersExpectation
	expectations       []*LOMSRepoMockListUnpaidOrdersExpectation

	callArgs []*LOMSRepoMockListUnpaidOrdersParams
	mutex    sync.RWMutex
}

// LOMSRepoMockListUnpaidOrdersExpectation specifies expectation struct of the LOMSRepo.ListUnpaidOrders
type LOMSRepoMockListUnpaidOrdersExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockListUnpaidOrdersParams
	results *LOMSRepoMockListUnpaidOrdersResults
	Counter uint64
}

// LOMSRepoMockListUnpaidOrdersParams contains parameters of the LOMSRepo.ListUnpaidOrders
type LOMSRepoMockListUnpaidOrdersParams struct {
	ctx         context.Context
	paymentWait time.Duration
}

// LOMSRepoMockListUnpaidOrdersResults contains results of the LOMSRepo.ListUnpaidOrders
type LOMSRepoMockListUnpaidOrdersResults struct {
	ia1 []int64
	err error
}

// Expect sets up expected params for LOMSRepo.ListUnpaidOrders
func (mmListUnpaidOrders *mLOMSRepoMockListUnpaidOrders) Expect(ctx context.Context, paymentWait time.Duration) *mLOMSRepoMockListUnpaidOrders {
	if mmListUnpaidOrders.mock.funcListUnpaidOrders != nil {
		mmListUnpaidOrders.mock.t.Fatalf("LOMSRepoMock.ListUnpaidOrders mock is already set by Set")
	}

	if mmListUnpaidOrders.defaultExpectation == nil {
		mmListUnpaidOrders.defaultExpectation = &LOMSRepoMockListUnpaidOrdersExpectation{}
	}

	mmListUnpaidOrders.defaultExpectation.params = &LOMSRepoMockListUnpaidOrdersParams{ctx, paymentWait}
	for _, e := range mmListUnpaidOrders.expectations {
		if minimock.Equal(e.params, mmListUnpaidOrders.defaultExpectation.params) {
			mmListUnpaidOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListUnpaidOrders.defaultExpectation.params)
		}
	}

	return mmListUnpaidOrders
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.ListUnpaidOrders
func (mmListUnpaidOrders *mLOMSRepoMockListUnpaidOrders) Inspect(f func(ctx context.Context, paymentWait time.Duration)) *mLOMSRepoMockListUnpaidOrders {
	if mmListUnpaidOrders.mock.inspectFuncListUnpaidOrders != nil {
		mmListUnpaidOrders.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.ListUnpaidOrders")
	}

	mmListUnpaidOrders.mock.inspectFuncListUnpaidOrders = f

	return mmListUnpaidOrders
}

// Return sets up results that will be returned by LOMSRepo.ListUnpaidOrders
func (mmListUnpaidOrders *mLOMSRepoMockListUnpaidOrders) Return(ia1 []int64, err error) *LOMSRepoMock {
	if mmListUnpaidOrders.mock.funcListUnpaidOrders != nil {
		mmListUnpaidOrders.mock.t.Fatalf("LOMSRepoMock.ListUnpaidOrders mock is already set by Set")
	}

	if mmListUnpaidOrders.defaultExpectation == nil {
		mmListUnpaidOrders.defaultExpectation = &LOMSRepoMockListUnpaidOrdersExpectation{mock: mmListUnpaidOrders.mock}
	}
	mmListUnpaidOrders.defaultExpectation.results = &LOMSRepoMockListUnpaidOrdersResults{ia1, err}
	return mmListUnpaidOrders.mock
}

// Set uses given function f to mock the LOMSRepo.ListUnpaidOrders method
func (mmListUnpaidOrders *mLOMSRepoMockListUnpaidOrders) Set(f func(ctx context.Context, paymentWait time.Duration) (ia1 []int64, err error)) *LOMSRepoMock {
	if mmListUnpaidOrders.defaultExpectation != nil {
		mmListUnpaidOrders.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.ListUnpaidOrders method")
	}

	if len(mmListUnpaidOrders.expectations) > 0 {
		mmListUnpaidOrders.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.ListUnpaidOrders method")
	}

	mmListUnpaidOrders.mock.funcListUnpaidOrders = f
	return mmListUnpaidOrders.mock
}

// When sets expectation for the LOMSRepo.ListUnpaidOrders which will trigger the result defined by the following
// Then helper
func (mmListUnpaidOrders *mLOMSRepoMockListUnpaidOrders) When(ctx context.Context, paymentWait time.Duration) *LOMSRepoMockListUnpaidOrdersExpectation {
	if mmListUnpaidOrders.mock.funcListUnpaidOrders != nil {
		mmListUnpaidOrders.mock.t.Fatalf("LOMSRepoMock.ListUnpaidOrders mock is already set by Set")
	}

	expectation := &LOMSRepoMockListUnpaidOrdersExpectation{
		mock:   mmListUnpaidOrders.mock,
		params: &LOMSRepoMockListUnpaidOrdersParams{ctx, paymentWait},
	}
	mmListUnpaidOrders.expectations = append(mmListUnpaidOrders.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.ListUnpaidOrders return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockListUnpaidOrdersExpectation) Then(ia1 []int64, err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockListUnpaidOrdersResults{ia1, err}
	return e.mock
}

// ListUnpaidOrders implements domain.LOMSRepo
func (mmListUnpaidOrders *LOMSRepoMock) ListUnpaidOrders(ctx context.Context, paymentWait time.Duration) (ia1 []int64, err error) {
	mm_atomic.AddUint64(&mmListUnpaidOrders.beforeListUnpaidOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListUnpaidOrders.afterListUnpaidOrdersCounter, 1)

	if mmListUnpaidOrders.inspectFuncListUnpaidOrders != nil {
		mmListUnpaidOrders.inspectFuncListUnpaidOrders(ctx, paymentWait)
	}

	mm_params := &LOMSRepoMockListUnpaidOrdersParams{ctx, paymentWait}

	// Record call args
	mmListUnpaidOrders.ListUnpaidOrdersMock.mutex.Lock()
	mmListUnpaidOrders.ListUnpaidOrdersMock.callArgs = append(mmListUnpaidOrders.ListUnpaidOrdersMock.callArgs, mm_params)
	mmListUnpaidOrders.ListUnpaidOrdersMock.mutex.Unlock()

	for _, e := range mmListUnpaidOrders.ListUnpaidOrdersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmListUnpaidOrders.ListUnpaidOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListUnpaidOrders.ListUnpaidOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListUnpaidOrders.ListUnpaidOrdersMock.defaultExpectation.params
		mm_got := LOMSRepoMockListUnpaidOrdersParams{ctx, paymentWait}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListUnpaidOrders.t.Errorf("LOMSRepoMock.ListUnpaidOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListUnpaidOrders.ListUnpaidOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListUnpaidOrders.t.Fatal("No results are set for the LOMSRepoMock.ListUnpaidOrders")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmListUnpaidOrders.funcListUnpaidOrders != nil {
		return mmListUnpaidOrders.funcListUnpaidOrders(ctx, paymentWait)
	}
	mmListUnpaidOrders.t.Fatalf("Unexpected call to LOMSRepoMock.ListUnpaidOrders. %v %v", ctx, paymentWait)
	return
}

// ListUnpaidOrdersAfterCounter returns a count of finished LOMSRepoMock.ListUnpaidOrders invocations
func (mmListUnpaidOrders *LOMSRepoMock) ListUnpaidOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUnpaidOrders.afterListUnpaidOrdersCounter)
}

// ListUnpaidOrdersBeforeCounter returns a count of LOMSRepoMock.ListUnpaidOrders invocations
func (mmListUnpaidOrders *LOMSRepoMock) ListUnpaidOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUnpaidOrders.beforeListUnpaidOrdersCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.ListUnpaidOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListUnpaidOrders *mLOMSRepoMockListUnpaidOrders) Calls() []*LOMSRepoMockListUnpaidOrdersParams {
	mmListUnpaidOrders.mutex.RLock()

	argCopy := make([]*LOMSRepoMockListUnpaidOrdersParams, len(mmListUnpaidOrders.callArgs))
	copy(argCopy, mmListUnpaidOrders.callArgs)

	mmListUnpaidOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListUnpaidOrdersDone returns true if the count of the ListUnpaidOrders invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockListUnpaidOrdersDone() bool {
	for _, e := range m.ListUnpaidOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListUnpaidOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListUnpaidOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListUnpaidOrders != nil && mm_atomic.LoadUint64(&m.afterListUnpaidOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockListUnpaidOrdersInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockListUnpaidOrdersInspect() {
	for _, e := range m.ListUnpaidOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.ListUnpaidOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListUnpaidOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListUnpaidOrdersCounter) < 1 {
		if m.ListUnpaidOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.ListUnpaidOrders")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.ListUnpaidOrders with params: %#v", *m.ListUnpaidOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListUnpaidOrders != nil && mm_atomic.LoadUint64(&m.afterListUnpaidOrdersCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.ListUnpaidOrders")
	}
}

type mLOMSRepoMockPayOrder struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockPayOrderExpectation
	expectations       []*LOMSRepoMockPayOrderExpectation

	callArgs []*LOMSRepoMockPayOrderParams
	mutex    sync.RWMutex
}

// LOMSRepoMockPayOrderExpectation specifies expectation struct of the LOMSRepo.PayOrder
type LOMSRepoMockPayOrderExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockPayOrderParams
	results *LOMSRepoMockPayOrderResults
	Counter uint64
}

// LOMSRepoMockPayOrderParams contains parameters of the LOMSRepo.PayOrder
type LOMSRepoMockPayOrderParams struct {
	ctx     context.Context
	orderID int64
}

// LOMSRepoMockPayOrderResults contains results of the LOMSRepo.PayOrder
type LOMSRepoMockPayOrderResults struct {
	err error
}

// Expect sets up expected params for LOMSRepo.PayOrder
func (mmPayOrder *mLOMSRepoMockPayOrder) Expect(ctx context.Context, orderID int64) *mLOMSRepoMockPayOrder {
	if mmPayOrder.mock.funcPayOrder != nil {
		mmPayOrder.mock.t.Fatalf("LOMSRepoMock.PayOrder mock is already set by Set")
	}

	if mmPayOrder.defaultExpectation == nil {
		mmPayOrder.defaultExpectation = &LOMSRepoMockPayOrderExpectation{}
	}

	mmPayOrder.defaultExpectation.params = &LOMSRepoMockPayOrderParams{ctx, orderID}
	for _, e := range mmPayOrder.expectations {
		if minimock.Equal(e.params, mmPayOrder.defaultExpectation.params) {
			mmPayOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPayOrder.defaultExpectation.params)
		}
	}

	return mmPayOrder
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.PayOrder
func (mmPayOrder *mLOMSRepoMockPayOrder) Inspect(f func(ctx context.Context, orderID int64)) *mLOMSRepoMockPayOrder {
	if mmPayOrder.mock.inspectFuncPayOrder != nil {
		mmPayOrder.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.PayOrder")
	}

	mmPayOrder.mock.inspectFuncPayOrder = f

	return mmPayOrder
}

// Return sets up results that will be returned by LOMSRepo.PayOrder
func (mmPayOrder *mLOMSRepoMockPayOrder) Return(err error) *LOMSRepoMock {
	if mmPayOrder.mock.funcPayOrder != nil {
		mmPayOrder.mock.t.Fatalf("LOMSRepoMock.PayOrder mock is already set by Set")
	}

	if mmPayOrder.defaultExpectation == nil {
		mmPayOrder.defaultExpectation = &LOMSRepoMockPayOrderExpectation{mock: mmPayOrder.mock}
	}
	mmPayOrder.defaultExpectation.results = &LOMSRepoMockPayOrderResults{err}
	return mmPayOrder.mock
}

// Set uses given function f to mock the LOMSRepo.PayOrder method
func (mmPayOrder *mLOMSRepoMockPayOrder) Set(f func(ctx context.Context, orderID int64) (err error)) *LOMSRepoMock {
	if mmPayOrder.defaultExpectation != nil {
		mmPayOrder.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.PayOrder method")
	}

	if len(mmPayOrder.expectations) > 0 {
		mmPayOrder.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.PayOrder method")
	}

	mmPayOrder.mock.funcPayOrder = f
	return mmPayOrder.mock
}

// When sets expectation for the LOMSRepo.PayOrder which will trigger the result defined by the following
// Then helper
func (mmPayOrder *mLOMSRepoMockPayOrder) When(ctx context.Context, orderID int64) *LOMSRepoMockPayOrderExpectation {
	if mmPayOrder.mock.funcPayOrder != nil {
		mmPayOrder.mock.t.Fatalf("LOMSRepoMock.PayOrder mock is already set by Set")
	}

	expectation := &LOMSRepoMockPayOrderExpectation{
		mock:   mmPayOrder.mock,
		params: &LOMSRepoMockPayOrderParams{ctx, orderID},
	}
	mmPayOrder.expectations = append(mmPayOrder.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.PayOrder return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockPayOrderExpectation) Then(err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockPayOrderResults{err}
	return e.mock
}

// PayOrder implements domain.LOMSRepo
func (mmPayOrder *LOMSRepoMock) PayOrder(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmPayOrder.beforePayOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmPayOrder.afterPayOrderCounter, 1)

	if mmPayOrder.inspectFuncPayOrder != nil {
		mmPayOrder.inspectFuncPayOrder(ctx, orderID)
	}

	mm_params := &LOMSRepoMockPayOrderParams{ctx, orderID}

	// Record call args
	mmPayOrder.PayOrderMock.mutex.Lock()
	mmPayOrder.PayOrderMock.callArgs = append(mmPayOrder.PayOrderMock.callArgs, mm_params)
	mmPayOrder.PayOrderMock.mutex.Unlock()

	for _, e := range mmPayOrder.PayOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPayOrder.PayOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPayOrder.PayOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmPayOrder.PayOrderMock.defaultExpectation.params
		mm_got := LOMSRepoMockPayOrderParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPayOrder.t.Errorf("LOMSRepoMock.PayOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPayOrder.PayOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmPayOrder.t.Fatal("No results are set for the LOMSRepoMock.PayOrder")
		}
		return (*mm_results).err
	}
	if mmPayOrder.funcPayOrder != nil {
		return mmPayOrder.funcPayOrder(ctx, orderID)
	}
	mmPayOrder.t.Fatalf("Unexpected call to LOMSRepoMock.PayOrder. %v %v", ctx, orderID)
	return
}

// PayOrderAfterCounter returns a count of finished LOMSRepoMock.PayOrder invocations
func (mmPayOrder *LOMSRepoMock) PayOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPayOrder.afterPayOrderCounter)
}

// PayOrderBeforeCounter returns a count of LOMSRepoMock.PayOrder invocations
func (mmPayOrder *LOMSRepoMock) PayOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPayOrder.beforePayOrderCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.PayOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPayOrder *mLOMSRepoMockPayOrder) Calls() []*LOMSRepoMockPayOrderParams {
	mmPayOrder.mutex.RLock()

	argCopy := make([]*LOMSRepoMockPayOrderParams, len(mmPayOrder.callArgs))
	copy(argCopy, mmPayOrder.callArgs)

	mmPayOrder.mutex.RUnlock()

	return argCopy
}

// MinimockPayOrderDone returns true if the count of the PayOrder invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockPayOrderDone() bool {
	for _, e := range m.PayOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PayOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPayOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPayOrder != nil && mm_atomic.LoadUint64(&m.afterPayOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockPayOrderInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockPayOrderInspect() {
	for _, e := range m.PayOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.PayOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PayOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPayOrderCounter) < 1 {
		if m.PayOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.PayOrder")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.PayOrder with params: %#v", *m.PayOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPayOrder != nil && mm_atomic.LoadUint64(&m.afterPayOrderCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.PayOrder")
	}
}

type mLOMSRepoMockRemoveItemsFromReserved struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockRemoveItemsFromReservedExpectation
	expectations       []*LOMSRepoMockRemoveItemsFromReservedExpectation

	callArgs []*LOMSRepoMockRemoveItemsFromReservedParams
	mutex    sync.RWMutex
}

// LOMSRepoMockRemoveItemsFromReservedExpectation specifies expectation struct of the LOMSRepo.RemoveItemsFromReserved
type LOMSRepoMockRemoveItemsFromReservedExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockRemoveItemsFromReservedParams
	results *LOMSRepoMockRemoveItemsFromReservedResults
	Counter uint64
}

// LOMSRepoMockRemoveItemsFromReservedParams contains parameters of the LOMSRepo.RemoveItemsFromReserved
type LOMSRepoMockRemoveItemsFromReservedParams struct {
	ctx     context.Context
	orderID int64
}

// LOMSRepoMockRemoveItemsFromReservedResults contains results of the LOMSRepo.RemoveItemsFromReserved
type LOMSRepoMockRemoveItemsFromReservedResults struct {
	ia1 []int64
	sa1 []model.Stock
	err error
}

// Expect sets up expected params for LOMSRepo.RemoveItemsFromReserved
func (mmRemoveItemsFromReserved *mLOMSRepoMockRemoveItemsFromReserved) Expect(ctx context.Context, orderID int64) *mLOMSRepoMockRemoveItemsFromReserved {
	if mmRemoveItemsFromReserved.mock.funcRemoveItemsFromReserved != nil {
		mmRemoveItemsFromReserved.mock.t.Fatalf("LOMSRepoMock.RemoveItemsFromReserved mock is already set by Set")
	}

	if mmRemoveItemsFromReserved.defaultExpectation == nil {
		mmRemoveItemsFromReserved.defaultExpectation = &LOMSRepoMockRemoveItemsFromReservedExpectation{}
	}

	mmRemoveItemsFromReserved.defaultExpectation.params = &LOMSRepoMockRemoveItemsFromReservedParams{ctx, orderID}
	for _, e := range mmRemoveItemsFromReserved.expectations {
		if minimock.Equal(e.params, mmRemoveItemsFromReserved.defaultExpectation.params) {
			mmRemoveItemsFromReserved.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveItemsFromReserved.defaultExpectation.params)
		}
	}

	return mmRemoveItemsFromReserved
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.RemoveItemsFromReserved
func (mmRemoveItemsFromReserved *mLOMSRepoMockRemoveItemsFromReserved) Inspect(f func(ctx context.Context, orderID int64)) *mLOMSRepoMockRemoveItemsFromReserved {
	if mmRemoveItemsFromReserved.mock.inspectFuncRemoveItemsFromReserved != nil {
		mmRemoveItemsFromReserved.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.RemoveItemsFromReserved")
	}

	mmRemoveItemsFromReserved.mock.inspectFuncRemoveItemsFromReserved = f

	return mmRemoveItemsFromReserved
}

// Return sets up results that will be returned by LOMSRepo.RemoveItemsFromReserved
func (mmRemoveItemsFromReserved *mLOMSRepoMockRemoveItemsFromReserved) Return(ia1 []int64, sa1 []model.Stock, err error) *LOMSRepoMock {
	if mmRemoveItemsFromReserved.mock.funcRemoveItemsFromReserved != nil {
		mmRemoveItemsFromReserved.mock.t.Fatalf("LOMSRepoMock.RemoveItemsFromReserved mock is already set by Set")
	}

	if mmRemoveItemsFromReserved.defaultExpectation == nil {
		mmRemoveItemsFromReserved.defaultExpectation = &LOMSRepoMockRemoveItemsFromReservedExpectation{mock: mmRemoveItemsFromReserved.mock}
	}
	mmRemoveItemsFromReserved.defaultExpectation.results = &LOMSRepoMockRemoveItemsFromReservedResults{ia1, sa1, err}
	return mmRemoveItemsFromReserved.mock
}

// Set uses given function f to mock the LOMSRepo.RemoveItemsFromReserved method
func (mmRemoveItemsFromReserved *mLOMSRepoMockRemoveItemsFromReserved) Set(f func(ctx context.Context, orderID int64) (ia1 []int64, sa1 []model.Stock, err error)) *LOMSRepoMock {
	if mmRemoveItemsFromReserved.defaultExpectation != nil {
		mmRemoveItemsFromReserved.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.RemoveItemsFromReserved method")
	}

	if len(mmRemoveItemsFromReserved.expectations) > 0 {
		mmRemoveItemsFromReserved.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.RemoveItemsFromReserved method")
	}

	mmRemoveItemsFromReserved.mock.funcRemoveItemsFromReserved = f
	return mmRemoveItemsFromReserved.mock
}

// When sets expectation for the LOMSRepo.RemoveItemsFromReserved which will trigger the result defined by the following
// Then helper
func (mmRemoveItemsFromReserved *mLOMSRepoMockRemoveItemsFromReserved) When(ctx context.Context, orderID int64) *LOMSRepoMockRemoveItemsFromReservedExpectation {
	if mmRemoveItemsFromReserved.mock.funcRemoveItemsFromReserved != nil {
		mmRemoveItemsFromReserved.mock.t.Fatalf("LOMSRepoMock.RemoveItemsFromReserved mock is already set by Set")
	}

	expectation := &LOMSRepoMockRemoveItemsFromReservedExpectation{
		mock:   mmRemoveItemsFromReserved.mock,
		params: &LOMSRepoMockRemoveItemsFromReservedParams{ctx, orderID},
	}
	mmRemoveItemsFromReserved.expectations = append(mmRemoveItemsFromReserved.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.RemoveItemsFromReserved return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockRemoveItemsFromReservedExpectation) Then(ia1 []int64, sa1 []model.Stock, err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockRemoveItemsFromReservedResults{ia1, sa1, err}
	return e.mock
}

// RemoveItemsFromReserved implements domain.LOMSRepo
func (mmRemoveItemsFromReserved *LOMSRepoMock) RemoveItemsFromReserved(ctx context.Context, orderID int64) (ia1 []int64, sa1 []model.Stock, err error) {
	mm_atomic.AddUint64(&mmRemoveItemsFromReserved.beforeRemoveItemsFromReservedCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveItemsFromReserved.afterRemoveItemsFromReservedCounter, 1)

	if mmRemoveItemsFromReserved.inspectFuncRemoveItemsFromReserved != nil {
		mmRemoveItemsFromReserved.inspectFuncRemoveItemsFromReserved(ctx, orderID)
	}

	mm_params := &LOMSRepoMockRemoveItemsFromReservedParams{ctx, orderID}

	// Record call args
	mmRemoveItemsFromReserved.RemoveItemsFromReservedMock.mutex.Lock()
	mmRemoveItemsFromReserved.RemoveItemsFromReservedMock.callArgs = append(mmRemoveItemsFromReserved.RemoveItemsFromReservedMock.callArgs, mm_params)
	mmRemoveItemsFromReserved.RemoveItemsFromReservedMock.mutex.Unlock()

	for _, e := range mmRemoveItemsFromReserved.RemoveItemsFromReservedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.sa1, e.results.err
		}
	}

	if mmRemoveItemsFromReserved.RemoveItemsFromReservedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveItemsFromReserved.RemoveItemsFromReservedMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveItemsFromReserved.RemoveItemsFromReservedMock.defaultExpectation.params
		mm_got := LOMSRepoMockRemoveItemsFromReservedParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveItemsFromReserved.t.Errorf("LOMSRepoMock.RemoveItemsFromReserved got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveItemsFromReserved.RemoveItemsFromReservedMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveItemsFromReserved.t.Fatal("No results are set for the LOMSRepoMock.RemoveItemsFromReserved")
		}
		return (*mm_results).ia1, (*mm_results).sa1, (*mm_results).err
	}
	if mmRemoveItemsFromReserved.funcRemoveItemsFromReserved != nil {
		return mmRemoveItemsFromReserved.funcRemoveItemsFromReserved(ctx, orderID)
	}
	mmRemoveItemsFromReserved.t.Fatalf("Unexpected call to LOMSRepoMock.RemoveItemsFromReserved. %v %v", ctx, orderID)
	return
}

// RemoveItemsFromReservedAfterCounter returns a count of finished LOMSRepoMock.RemoveItemsFromReserved invocations
func (mmRemoveItemsFromReserved *LOMSRepoMock) RemoveItemsFromReservedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveItemsFromReserved.afterRemoveItemsFromReservedCounter)
}

// RemoveItemsFromReservedBeforeCounter returns a count of LOMSRepoMock.RemoveItemsFromReserved invocations
func (mmRemoveItemsFromReserved *LOMSRepoMock) RemoveItemsFromReservedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveItemsFromReserved.beforeRemoveItemsFromReservedCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.RemoveItemsFromReserved.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveItemsFromReserved *mLOMSRepoMockRemoveItemsFromReserved) Calls() []*LOMSRepoMockRemoveItemsFromReservedParams {
	mmRemoveItemsFromReserved.mutex.RLock()

	argCopy := make([]*LOMSRepoMockRemoveItemsFromReservedParams, len(mmRemoveItemsFromReserved.callArgs))
	copy(argCopy, mmRemoveItemsFromReserved.callArgs)

	mmRemoveItemsFromReserved.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveItemsFromReservedDone returns true if the count of the RemoveItemsFromReserved invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockRemoveItemsFromReservedDone() bool {
	for _, e := range m.RemoveItemsFromReservedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveItemsFromReservedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveItemsFromReservedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveItemsFromReserved != nil && mm_atomic.LoadUint64(&m.afterRemoveItemsFromReservedCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveItemsFromReservedInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockRemoveItemsFromReservedInspect() {
	for _, e := range m.RemoveItemsFromReservedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.RemoveItemsFromReserved with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveItemsFromReservedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveItemsFromReservedCounter) < 1 {
		if m.RemoveItemsFromReservedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.RemoveItemsFromReserved")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.RemoveItemsFromReserved with params: %#v", *m.RemoveItemsFromReservedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveItemsFromReserved != nil && mm_atomic.LoadUint64(&m.afterRemoveItemsFromReservedCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.RemoveItemsFromReserved")
	}
}

type mLOMSRepoMockReserveItem struct {
	mock               *LOMSRepoMock
	defaultExpectation *LOMSRepoMockReserveItemExpectation
	expectations       []*LOMSRepoMockReserveItemExpectation

	callArgs []*LOMSRepoMockReserveItemParams
	mutex    sync.RWMutex
}

// LOMSRepoMockReserveItemExpectation specifies expectation struct of the LOMSRepo.ReserveItem
type LOMSRepoMockReserveItemExpectation struct {
	mock    *LOMSRepoMock
	params  *LOMSRepoMockReserveItemParams
	results *LOMSRepoMockReserveItemResults
	Counter uint64
}

// LOMSRepoMockReserveItemParams contains parameters of the LOMSRepo.ReserveItem
type LOMSRepoMockReserveItemParams struct {
	ctx     context.Context
	orderID int64
	sku     int64
	stock   model.Stock
}

// LOMSRepoMockReserveItemResults contains results of the LOMSRepo.ReserveItem
type LOMSRepoMockReserveItemResults struct {
	err error
}

// Expect sets up expected params for LOMSRepo.ReserveItem
func (mmReserveItem *mLOMSRepoMockReserveItem) Expect(ctx context.Context, orderID int64, sku int64, stock model.Stock) *mLOMSRepoMockReserveItem {
	if mmReserveItem.mock.funcReserveItem != nil {
		mmReserveItem.mock.t.Fatalf("LOMSRepoMock.ReserveItem mock is already set by Set")
	}

	if mmReserveItem.defaultExpectation == nil {
		mmReserveItem.defaultExpectation = &LOMSRepoMockReserveItemExpectation{}
	}

	mmReserveItem.defaultExpectation.params = &LOMSRepoMockReserveItemParams{ctx, orderID, sku, stock}
	for _, e := range mmReserveItem.expectations {
		if minimock.Equal(e.params, mmReserveItem.defaultExpectation.params) {
			mmReserveItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveItem.defaultExpectation.params)
		}
	}

	return mmReserveItem
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepo.ReserveItem
func (mmReserveItem *mLOMSRepoMockReserveItem) Inspect(f func(ctx context.Context, orderID int64, sku int64, stock model.Stock)) *mLOMSRepoMockReserveItem {
	if mmReserveItem.mock.inspectFuncReserveItem != nil {
		mmReserveItem.mock.t.Fatalf("Inspect function is already set for LOMSRepoMock.ReserveItem")
	}

	mmReserveItem.mock.inspectFuncReserveItem = f

	return mmReserveItem
}

// Return sets up results that will be returned by LOMSRepo.ReserveItem
func (mmReserveItem *mLOMSRepoMockReserveItem) Return(err error) *LOMSRepoMock {
	if mmReserveItem.mock.funcReserveItem != nil {
		mmReserveItem.mock.t.Fatalf("LOMSRepoMock.ReserveItem mock is already set by Set")
	}

	if mmReserveItem.defaultExpectation == nil {
		mmReserveItem.defaultExpectation = &LOMSRepoMockReserveItemExpectation{mock: mmReserveItem.mock}
	}
	mmReserveItem.defaultExpectation.results = &LOMSRepoMockReserveItemResults{err}
	return mmReserveItem.mock
}

// Set uses given function f to mock the LOMSRepo.ReserveItem method
func (mmReserveItem *mLOMSRepoMockReserveItem) Set(f func(ctx context.Context, orderID int64, sku int64, stock model.Stock) (err error)) *LOMSRepoMock {
	if mmReserveItem.defaultExpectation != nil {
		mmReserveItem.mock.t.Fatalf("Default expectation is already set for the LOMSRepo.ReserveItem method")
	}

	if len(mmReserveItem.expectations) > 0 {
		mmReserveItem.mock.t.Fatalf("Some expectations are already set for the LOMSRepo.ReserveItem method")
	}

	mmReserveItem.mock.funcReserveItem = f
	return mmReserveItem.mock
}

// When sets expectation for the LOMSRepo.ReserveItem which will trigger the result defined by the following
// Then helper
func (mmReserveItem *mLOMSRepoMockReserveItem) When(ctx context.Context, orderID int64, sku int64, stock model.Stock) *LOMSRepoMockReserveItemExpectation {
	if mmReserveItem.mock.funcReserveItem != nil {
		mmReserveItem.mock.t.Fatalf("LOMSRepoMock.ReserveItem mock is already set by Set")
	}

	expectation := &LOMSRepoMockReserveItemExpectation{
		mock:   mmReserveItem.mock,
		params: &LOMSRepoMockReserveItemParams{ctx, orderID, sku, stock},
	}
	mmReserveItem.expectations = append(mmReserveItem.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepo.ReserveItem return parameters for the expectation previously defined by the When method
func (e *LOMSRepoMockReserveItemExpectation) Then(err error) *LOMSRepoMock {
	e.results = &LOMSRepoMockReserveItemResults{err}
	return e.mock
}

// ReserveItem implements domain.LOMSRepo
func (mmReserveItem *LOMSRepoMock) ReserveItem(ctx context.Context, orderID int64, sku int64, stock model.Stock) (err error) {
	mm_atomic.AddUint64(&mmReserveItem.beforeReserveItemCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveItem.afterReserveItemCounter, 1)

	if mmReserveItem.inspectFuncReserveItem != nil {
		mmReserveItem.inspectFuncReserveItem(ctx, orderID, sku, stock)
	}

	mm_params := &LOMSRepoMockReserveItemParams{ctx, orderID, sku, stock}

	// Record call args
	mmReserveItem.ReserveItemMock.mutex.Lock()
	mmReserveItem.ReserveItemMock.callArgs = append(mmReserveItem.ReserveItemMock.callArgs, mm_params)
	mmReserveItem.ReserveItemMock.mutex.Unlock()

	for _, e := range mmReserveItem.ReserveItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveItem.ReserveItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveItem.ReserveItemMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveItem.ReserveItemMock.defaultExpectation.params
		mm_got := LOMSRepoMockReserveItemParams{ctx, orderID, sku, stock}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveItem.t.Errorf("LOMSRepoMock.ReserveItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveItem.ReserveItemMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveItem.t.Fatal("No results are set for the LOMSRepoMock.ReserveItem")
		}
		return (*mm_results).err
	}
	if mmReserveItem.funcReserveItem != nil {
		return mmReserveItem.funcReserveItem(ctx, orderID, sku, stock)
	}
	mmReserveItem.t.Fatalf("Unexpected call to LOMSRepoMock.ReserveItem. %v %v %v %v", ctx, orderID, sku, stock)
	return
}

// ReserveItemAfterCounter returns a count of finished LOMSRepoMock.ReserveItem invocations
func (mmReserveItem *LOMSRepoMock) ReserveItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveItem.afterReserveItemCounter)
}

// ReserveItemBeforeCounter returns a count of LOMSRepoMock.ReserveItem invocations
func (mmReserveItem *LOMSRepoMock) ReserveItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveItem.beforeReserveItemCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepoMock.ReserveItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveItem *mLOMSRepoMockReserveItem) Calls() []*LOMSRepoMockReserveItemParams {
	mmReserveItem.mutex.RLock()

	argCopy := make([]*LOMSRepoMockReserveItemParams, len(mmReserveItem.callArgs))
	copy(argCopy, mmReserveItem.callArgs)

	mmReserveItem.mutex.RUnlock()

	return argCopy
}

// MinimockReserveItemDone returns true if the count of the ReserveItem invocations corresponds
// the number of defined expectations
func (m *LOMSRepoMock) MinimockReserveItemDone() bool {
	for _, e := range m.ReserveItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveItem != nil && mm_atomic.LoadUint64(&m.afterReserveItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockReserveItemInspect logs each unmet expectation
func (m *LOMSRepoMock) MinimockReserveItemInspect() {
	for _, e := range m.ReserveItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepoMock.ReserveItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveItemCounter) < 1 {
		if m.ReserveItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepoMock.ReserveItem")
		} else {
			m.t.Errorf("Expected call to LOMSRepoMock.ReserveItem with params: %#v", *m.ReserveItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveItem != nil && mm_atomic.LoadUint64(&m.afterReserveItemCounter) < 1 {
		m.t.Error("Expected call to LOMSRepoMock.ReserveItem")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LOMSRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCancelOrderInspect()

		m.MinimockChangeOrderStatusInspect()

		m.MinimockDecreaseStockInspect()

		m.MinimockGetStocksInspect()

		m.MinimockIncreaseStockInspect()

		m.MinimockInsertOrderInfoInspect()

		m.MinimockInsertOrderItemsInspect()

		m.MinimockListOrderInfoInspect()

		m.MinimockListOrderItemsInspect()

		m.MinimockListUnpaidOrdersInspect()

		m.MinimockPayOrderInspect()

		m.MinimockRemoveItemsFromReservedInspect()

		m.MinimockReserveItemInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LOMSRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LOMSRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelOrderDone() &&
		m.MinimockChangeOrderStatusDone() &&
		m.MinimockDecreaseStockDone() &&
		m.MinimockGetStocksDone() &&
		m.MinimockIncreaseStockDone() &&
		m.MinimockInsertOrderInfoDone() &&
		m.MinimockInsertOrderItemsDone() &&
		m.MinimockListOrderInfoDone() &&
		m.MinimockListOrderItemsDone() &&
		m.MinimockListUnpaidOrdersDone() &&
		m.MinimockPayOrderDone() &&
		m.MinimockRemoveItemsFromReservedDone() &&
		m.MinimockReserveItemDone()
}
