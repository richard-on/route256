package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/domain.CheckoutRepo -o ./mocks\checkout_repo_minimock.go -n CheckoutRepoMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/rragusskiy/homework-1/checkout/internal/model"
)

// CheckoutRepoMock implements domain.CheckoutRepo
type CheckoutRepoMock struct {
	t minimock.Tester

	funcAddToCart          func(ctx context.Context, userID int64, modelItem model.Item) (err error)
	inspectFuncAddToCart   func(ctx context.Context, userID int64, modelItem model.Item)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mCheckoutRepoMockAddToCart

	funcClearCart          func(ctx context.Context, userID int64) (err error)
	inspectFuncClearCart   func(ctx context.Context, userID int64)
	afterClearCartCounter  uint64
	beforeClearCartCounter uint64
	ClearCartMock          mCheckoutRepoMockClearCart

	funcDecreaseItemCartCount          func(ctx context.Context, userID int64, modelItem model.Item) (err error)
	inspectFuncDecreaseItemCartCount   func(ctx context.Context, userID int64, modelItem model.Item)
	afterDecreaseItemCartCountCounter  uint64
	beforeDecreaseItemCartCountCounter uint64
	DecreaseItemCartCountMock          mCheckoutRepoMockDecreaseItemCartCount

	funcDeleteItemCart          func(ctx context.Context, userID int64, sku uint32) (err error)
	inspectFuncDeleteItemCart   func(ctx context.Context, userID int64, sku uint32)
	afterDeleteItemCartCounter  uint64
	beforeDeleteItemCartCounter uint64
	DeleteItemCartMock          mCheckoutRepoMockDeleteItemCart

	funcGetCartItems          func(ctx context.Context, userID int64) (ia1 []model.Item, err error)
	inspectFuncGetCartItems   func(ctx context.Context, userID int64)
	afterGetCartItemsCounter  uint64
	beforeGetCartItemsCounter uint64
	GetCartItemsMock          mCheckoutRepoMockGetCartItems

	funcGetItemCartCount          func(ctx context.Context, userID int64, modelItem model.Item) (i1 int32, err error)
	inspectFuncGetItemCartCount   func(ctx context.Context, userID int64, modelItem model.Item)
	afterGetItemCartCountCounter  uint64
	beforeGetItemCartCountCounter uint64
	GetItemCartCountMock          mCheckoutRepoMockGetItemCartCount
}

// NewCheckoutRepoMock returns a mock for domain.CheckoutRepo
func NewCheckoutRepoMock(t minimock.Tester) *CheckoutRepoMock {
	m := &CheckoutRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mCheckoutRepoMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*CheckoutRepoMockAddToCartParams{}

	m.ClearCartMock = mCheckoutRepoMockClearCart{mock: m}
	m.ClearCartMock.callArgs = []*CheckoutRepoMockClearCartParams{}

	m.DecreaseItemCartCountMock = mCheckoutRepoMockDecreaseItemCartCount{mock: m}
	m.DecreaseItemCartCountMock.callArgs = []*CheckoutRepoMockDecreaseItemCartCountParams{}

	m.DeleteItemCartMock = mCheckoutRepoMockDeleteItemCart{mock: m}
	m.DeleteItemCartMock.callArgs = []*CheckoutRepoMockDeleteItemCartParams{}

	m.GetCartItemsMock = mCheckoutRepoMockGetCartItems{mock: m}
	m.GetCartItemsMock.callArgs = []*CheckoutRepoMockGetCartItemsParams{}

	m.GetItemCartCountMock = mCheckoutRepoMockGetItemCartCount{mock: m}
	m.GetItemCartCountMock.callArgs = []*CheckoutRepoMockGetItemCartCountParams{}

	return m
}

type mCheckoutRepoMockAddToCart struct {
	mock               *CheckoutRepoMock
	defaultExpectation *CheckoutRepoMockAddToCartExpectation
	expectations       []*CheckoutRepoMockAddToCartExpectation

	callArgs []*CheckoutRepoMockAddToCartParams
	mutex    sync.RWMutex
}

// CheckoutRepoMockAddToCartExpectation specifies expectation struct of the CheckoutRepo.AddToCart
type CheckoutRepoMockAddToCartExpectation struct {
	mock    *CheckoutRepoMock
	params  *CheckoutRepoMockAddToCartParams
	results *CheckoutRepoMockAddToCartResults
	Counter uint64
}

// CheckoutRepoMockAddToCartParams contains parameters of the CheckoutRepo.AddToCart
type CheckoutRepoMockAddToCartParams struct {
	ctx       context.Context
	userID    int64
	modelItem model.Item
}

// CheckoutRepoMockAddToCartResults contains results of the CheckoutRepo.AddToCart
type CheckoutRepoMockAddToCartResults struct {
	err error
}

// Expect sets up expected params for CheckoutRepo.AddToCart
func (mmAddToCart *mCheckoutRepoMockAddToCart) Expect(ctx context.Context, userID int64, modelItem model.Item) *mCheckoutRepoMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CheckoutRepoMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CheckoutRepoMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &CheckoutRepoMockAddToCartParams{ctx, userID, modelItem}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepo.AddToCart
func (mmAddToCart *mCheckoutRepoMockAddToCart) Inspect(f func(ctx context.Context, userID int64, modelItem model.Item)) *mCheckoutRepoMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for CheckoutRepoMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by CheckoutRepo.AddToCart
func (mmAddToCart *mCheckoutRepoMockAddToCart) Return(err error) *CheckoutRepoMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CheckoutRepoMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CheckoutRepoMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &CheckoutRepoMockAddToCartResults{err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the CheckoutRepo.AddToCart method
func (mmAddToCart *mCheckoutRepoMockAddToCart) Set(f func(ctx context.Context, userID int64, modelItem model.Item) (err error)) *CheckoutRepoMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the CheckoutRepo.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the CheckoutRepo.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the CheckoutRepo.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mCheckoutRepoMockAddToCart) When(ctx context.Context, userID int64, modelItem model.Item) *CheckoutRepoMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CheckoutRepoMock.AddToCart mock is already set by Set")
	}

	expectation := &CheckoutRepoMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &CheckoutRepoMockAddToCartParams{ctx, userID, modelItem},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepo.AddToCart return parameters for the expectation previously defined by the When method
func (e *CheckoutRepoMockAddToCartExpectation) Then(err error) *CheckoutRepoMock {
	e.results = &CheckoutRepoMockAddToCartResults{err}
	return e.mock
}

// AddToCart implements domain.CheckoutRepo
func (mmAddToCart *CheckoutRepoMock) AddToCart(ctx context.Context, userID int64, modelItem model.Item) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, userID, modelItem)
	}

	mm_params := &CheckoutRepoMockAddToCartParams{ctx, userID, modelItem}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := CheckoutRepoMockAddToCartParams{ctx, userID, modelItem}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("CheckoutRepoMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the CheckoutRepoMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, userID, modelItem)
	}
	mmAddToCart.t.Fatalf("Unexpected call to CheckoutRepoMock.AddToCart. %v %v %v", ctx, userID, modelItem)
	return
}

// AddToCartAfterCounter returns a count of finished CheckoutRepoMock.AddToCart invocations
func (mmAddToCart *CheckoutRepoMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of CheckoutRepoMock.AddToCart invocations
func (mmAddToCart *CheckoutRepoMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepoMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mCheckoutRepoMockAddToCart) Calls() []*CheckoutRepoMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*CheckoutRepoMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *CheckoutRepoMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *CheckoutRepoMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepoMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepoMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to CheckoutRepoMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepoMock.AddToCart")
	}
}

type mCheckoutRepoMockClearCart struct {
	mock               *CheckoutRepoMock
	defaultExpectation *CheckoutRepoMockClearCartExpectation
	expectations       []*CheckoutRepoMockClearCartExpectation

	callArgs []*CheckoutRepoMockClearCartParams
	mutex    sync.RWMutex
}

// CheckoutRepoMockClearCartExpectation specifies expectation struct of the CheckoutRepo.ClearCart
type CheckoutRepoMockClearCartExpectation struct {
	mock    *CheckoutRepoMock
	params  *CheckoutRepoMockClearCartParams
	results *CheckoutRepoMockClearCartResults
	Counter uint64
}

// CheckoutRepoMockClearCartParams contains parameters of the CheckoutRepo.ClearCart
type CheckoutRepoMockClearCartParams struct {
	ctx    context.Context
	userID int64
}

// CheckoutRepoMockClearCartResults contains results of the CheckoutRepo.ClearCart
type CheckoutRepoMockClearCartResults struct {
	err error
}

// Expect sets up expected params for CheckoutRepo.ClearCart
func (mmClearCart *mCheckoutRepoMockClearCart) Expect(ctx context.Context, userID int64) *mCheckoutRepoMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CheckoutRepoMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CheckoutRepoMockClearCartExpectation{}
	}

	mmClearCart.defaultExpectation.params = &CheckoutRepoMockClearCartParams{ctx, userID}
	for _, e := range mmClearCart.expectations {
		if minimock.Equal(e.params, mmClearCart.defaultExpectation.params) {
			mmClearCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCart.defaultExpectation.params)
		}
	}

	return mmClearCart
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepo.ClearCart
func (mmClearCart *mCheckoutRepoMockClearCart) Inspect(f func(ctx context.Context, userID int64)) *mCheckoutRepoMockClearCart {
	if mmClearCart.mock.inspectFuncClearCart != nil {
		mmClearCart.mock.t.Fatalf("Inspect function is already set for CheckoutRepoMock.ClearCart")
	}

	mmClearCart.mock.inspectFuncClearCart = f

	return mmClearCart
}

// Return sets up results that will be returned by CheckoutRepo.ClearCart
func (mmClearCart *mCheckoutRepoMockClearCart) Return(err error) *CheckoutRepoMock {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CheckoutRepoMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CheckoutRepoMockClearCartExpectation{mock: mmClearCart.mock}
	}
	mmClearCart.defaultExpectation.results = &CheckoutRepoMockClearCartResults{err}
	return mmClearCart.mock
}

// Set uses given function f to mock the CheckoutRepo.ClearCart method
func (mmClearCart *mCheckoutRepoMockClearCart) Set(f func(ctx context.Context, userID int64) (err error)) *CheckoutRepoMock {
	if mmClearCart.defaultExpectation != nil {
		mmClearCart.mock.t.Fatalf("Default expectation is already set for the CheckoutRepo.ClearCart method")
	}

	if len(mmClearCart.expectations) > 0 {
		mmClearCart.mock.t.Fatalf("Some expectations are already set for the CheckoutRepo.ClearCart method")
	}

	mmClearCart.mock.funcClearCart = f
	return mmClearCart.mock
}

// When sets expectation for the CheckoutRepo.ClearCart which will trigger the result defined by the following
// Then helper
func (mmClearCart *mCheckoutRepoMockClearCart) When(ctx context.Context, userID int64) *CheckoutRepoMockClearCartExpectation {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CheckoutRepoMock.ClearCart mock is already set by Set")
	}

	expectation := &CheckoutRepoMockClearCartExpectation{
		mock:   mmClearCart.mock,
		params: &CheckoutRepoMockClearCartParams{ctx, userID},
	}
	mmClearCart.expectations = append(mmClearCart.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepo.ClearCart return parameters for the expectation previously defined by the When method
func (e *CheckoutRepoMockClearCartExpectation) Then(err error) *CheckoutRepoMock {
	e.results = &CheckoutRepoMockClearCartResults{err}
	return e.mock
}

// ClearCart implements domain.CheckoutRepo
func (mmClearCart *CheckoutRepoMock) ClearCart(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmClearCart.beforeClearCartCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCart.afterClearCartCounter, 1)

	if mmClearCart.inspectFuncClearCart != nil {
		mmClearCart.inspectFuncClearCart(ctx, userID)
	}

	mm_params := &CheckoutRepoMockClearCartParams{ctx, userID}

	// Record call args
	mmClearCart.ClearCartMock.mutex.Lock()
	mmClearCart.ClearCartMock.callArgs = append(mmClearCart.ClearCartMock.callArgs, mm_params)
	mmClearCart.ClearCartMock.mutex.Unlock()

	for _, e := range mmClearCart.ClearCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCart.ClearCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCart.ClearCartMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCart.ClearCartMock.defaultExpectation.params
		mm_got := CheckoutRepoMockClearCartParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCart.t.Errorf("CheckoutRepoMock.ClearCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCart.ClearCartMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCart.t.Fatal("No results are set for the CheckoutRepoMock.ClearCart")
		}
		return (*mm_results).err
	}
	if mmClearCart.funcClearCart != nil {
		return mmClearCart.funcClearCart(ctx, userID)
	}
	mmClearCart.t.Fatalf("Unexpected call to CheckoutRepoMock.ClearCart. %v %v", ctx, userID)
	return
}

// ClearCartAfterCounter returns a count of finished CheckoutRepoMock.ClearCart invocations
func (mmClearCart *CheckoutRepoMock) ClearCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.afterClearCartCounter)
}

// ClearCartBeforeCounter returns a count of CheckoutRepoMock.ClearCart invocations
func (mmClearCart *CheckoutRepoMock) ClearCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.beforeClearCartCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepoMock.ClearCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCart *mCheckoutRepoMockClearCart) Calls() []*CheckoutRepoMockClearCartParams {
	mmClearCart.mutex.RLock()

	argCopy := make([]*CheckoutRepoMockClearCartParams, len(mmClearCart.callArgs))
	copy(argCopy, mmClearCart.callArgs)

	mmClearCart.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartDone returns true if the count of the ClearCart invocations corresponds
// the number of defined expectations
func (m *CheckoutRepoMock) MinimockClearCartDone() bool {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClearCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && mm_atomic.LoadUint64(&m.afterClearCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockClearCartInspect logs each unmet expectation
func (m *CheckoutRepoMock) MinimockClearCartInspect() {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepoMock.ClearCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClearCartCounter) < 1 {
		if m.ClearCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepoMock.ClearCart")
		} else {
			m.t.Errorf("Expected call to CheckoutRepoMock.ClearCart with params: %#v", *m.ClearCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && mm_atomic.LoadUint64(&m.afterClearCartCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepoMock.ClearCart")
	}
}

type mCheckoutRepoMockDecreaseItemCartCount struct {
	mock               *CheckoutRepoMock
	defaultExpectation *CheckoutRepoMockDecreaseItemCartCountExpectation
	expectations       []*CheckoutRepoMockDecreaseItemCartCountExpectation

	callArgs []*CheckoutRepoMockDecreaseItemCartCountParams
	mutex    sync.RWMutex
}

// CheckoutRepoMockDecreaseItemCartCountExpectation specifies expectation struct of the CheckoutRepo.DecreaseItemCartCount
type CheckoutRepoMockDecreaseItemCartCountExpectation struct {
	mock    *CheckoutRepoMock
	params  *CheckoutRepoMockDecreaseItemCartCountParams
	results *CheckoutRepoMockDecreaseItemCartCountResults
	Counter uint64
}

// CheckoutRepoMockDecreaseItemCartCountParams contains parameters of the CheckoutRepo.DecreaseItemCartCount
type CheckoutRepoMockDecreaseItemCartCountParams struct {
	ctx       context.Context
	userID    int64
	modelItem model.Item
}

// CheckoutRepoMockDecreaseItemCartCountResults contains results of the CheckoutRepo.DecreaseItemCartCount
type CheckoutRepoMockDecreaseItemCartCountResults struct {
	err error
}

// Expect sets up expected params for CheckoutRepo.DecreaseItemCartCount
func (mmDecreaseItemCartCount *mCheckoutRepoMockDecreaseItemCartCount) Expect(ctx context.Context, userID int64, modelItem model.Item) *mCheckoutRepoMockDecreaseItemCartCount {
	if mmDecreaseItemCartCount.mock.funcDecreaseItemCartCount != nil {
		mmDecreaseItemCartCount.mock.t.Fatalf("CheckoutRepoMock.DecreaseItemCartCount mock is already set by Set")
	}

	if mmDecreaseItemCartCount.defaultExpectation == nil {
		mmDecreaseItemCartCount.defaultExpectation = &CheckoutRepoMockDecreaseItemCartCountExpectation{}
	}

	mmDecreaseItemCartCount.defaultExpectation.params = &CheckoutRepoMockDecreaseItemCartCountParams{ctx, userID, modelItem}
	for _, e := range mmDecreaseItemCartCount.expectations {
		if minimock.Equal(e.params, mmDecreaseItemCartCount.defaultExpectation.params) {
			mmDecreaseItemCartCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDecreaseItemCartCount.defaultExpectation.params)
		}
	}

	return mmDecreaseItemCartCount
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepo.DecreaseItemCartCount
func (mmDecreaseItemCartCount *mCheckoutRepoMockDecreaseItemCartCount) Inspect(f func(ctx context.Context, userID int64, modelItem model.Item)) *mCheckoutRepoMockDecreaseItemCartCount {
	if mmDecreaseItemCartCount.mock.inspectFuncDecreaseItemCartCount != nil {
		mmDecreaseItemCartCount.mock.t.Fatalf("Inspect function is already set for CheckoutRepoMock.DecreaseItemCartCount")
	}

	mmDecreaseItemCartCount.mock.inspectFuncDecreaseItemCartCount = f

	return mmDecreaseItemCartCount
}

// Return sets up results that will be returned by CheckoutRepo.DecreaseItemCartCount
func (mmDecreaseItemCartCount *mCheckoutRepoMockDecreaseItemCartCount) Return(err error) *CheckoutRepoMock {
	if mmDecreaseItemCartCount.mock.funcDecreaseItemCartCount != nil {
		mmDecreaseItemCartCount.mock.t.Fatalf("CheckoutRepoMock.DecreaseItemCartCount mock is already set by Set")
	}

	if mmDecreaseItemCartCount.defaultExpectation == nil {
		mmDecreaseItemCartCount.defaultExpectation = &CheckoutRepoMockDecreaseItemCartCountExpectation{mock: mmDecreaseItemCartCount.mock}
	}
	mmDecreaseItemCartCount.defaultExpectation.results = &CheckoutRepoMockDecreaseItemCartCountResults{err}
	return mmDecreaseItemCartCount.mock
}

// Set uses given function f to mock the CheckoutRepo.DecreaseItemCartCount method
func (mmDecreaseItemCartCount *mCheckoutRepoMockDecreaseItemCartCount) Set(f func(ctx context.Context, userID int64, modelItem model.Item) (err error)) *CheckoutRepoMock {
	if mmDecreaseItemCartCount.defaultExpectation != nil {
		mmDecreaseItemCartCount.mock.t.Fatalf("Default expectation is already set for the CheckoutRepo.DecreaseItemCartCount method")
	}

	if len(mmDecreaseItemCartCount.expectations) > 0 {
		mmDecreaseItemCartCount.mock.t.Fatalf("Some expectations are already set for the CheckoutRepo.DecreaseItemCartCount method")
	}

	mmDecreaseItemCartCount.mock.funcDecreaseItemCartCount = f
	return mmDecreaseItemCartCount.mock
}

// When sets expectation for the CheckoutRepo.DecreaseItemCartCount which will trigger the result defined by the following
// Then helper
func (mmDecreaseItemCartCount *mCheckoutRepoMockDecreaseItemCartCount) When(ctx context.Context, userID int64, modelItem model.Item) *CheckoutRepoMockDecreaseItemCartCountExpectation {
	if mmDecreaseItemCartCount.mock.funcDecreaseItemCartCount != nil {
		mmDecreaseItemCartCount.mock.t.Fatalf("CheckoutRepoMock.DecreaseItemCartCount mock is already set by Set")
	}

	expectation := &CheckoutRepoMockDecreaseItemCartCountExpectation{
		mock:   mmDecreaseItemCartCount.mock,
		params: &CheckoutRepoMockDecreaseItemCartCountParams{ctx, userID, modelItem},
	}
	mmDecreaseItemCartCount.expectations = append(mmDecreaseItemCartCount.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepo.DecreaseItemCartCount return parameters for the expectation previously defined by the When method
func (e *CheckoutRepoMockDecreaseItemCartCountExpectation) Then(err error) *CheckoutRepoMock {
	e.results = &CheckoutRepoMockDecreaseItemCartCountResults{err}
	return e.mock
}

// DecreaseItemCartCount implements domain.CheckoutRepo
func (mmDecreaseItemCartCount *CheckoutRepoMock) DecreaseItemCartCount(ctx context.Context, userID int64, modelItem model.Item) (err error) {
	mm_atomic.AddUint64(&mmDecreaseItemCartCount.beforeDecreaseItemCartCountCounter, 1)
	defer mm_atomic.AddUint64(&mmDecreaseItemCartCount.afterDecreaseItemCartCountCounter, 1)

	if mmDecreaseItemCartCount.inspectFuncDecreaseItemCartCount != nil {
		mmDecreaseItemCartCount.inspectFuncDecreaseItemCartCount(ctx, userID, modelItem)
	}

	mm_params := &CheckoutRepoMockDecreaseItemCartCountParams{ctx, userID, modelItem}

	// Record call args
	mmDecreaseItemCartCount.DecreaseItemCartCountMock.mutex.Lock()
	mmDecreaseItemCartCount.DecreaseItemCartCountMock.callArgs = append(mmDecreaseItemCartCount.DecreaseItemCartCountMock.callArgs, mm_params)
	mmDecreaseItemCartCount.DecreaseItemCartCountMock.mutex.Unlock()

	for _, e := range mmDecreaseItemCartCount.DecreaseItemCartCountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDecreaseItemCartCount.DecreaseItemCartCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDecreaseItemCartCount.DecreaseItemCartCountMock.defaultExpectation.Counter, 1)
		mm_want := mmDecreaseItemCartCount.DecreaseItemCartCountMock.defaultExpectation.params
		mm_got := CheckoutRepoMockDecreaseItemCartCountParams{ctx, userID, modelItem}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDecreaseItemCartCount.t.Errorf("CheckoutRepoMock.DecreaseItemCartCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDecreaseItemCartCount.DecreaseItemCartCountMock.defaultExpectation.results
		if mm_results == nil {
			mmDecreaseItemCartCount.t.Fatal("No results are set for the CheckoutRepoMock.DecreaseItemCartCount")
		}
		return (*mm_results).err
	}
	if mmDecreaseItemCartCount.funcDecreaseItemCartCount != nil {
		return mmDecreaseItemCartCount.funcDecreaseItemCartCount(ctx, userID, modelItem)
	}
	mmDecreaseItemCartCount.t.Fatalf("Unexpected call to CheckoutRepoMock.DecreaseItemCartCount. %v %v %v", ctx, userID, modelItem)
	return
}

// DecreaseItemCartCountAfterCounter returns a count of finished CheckoutRepoMock.DecreaseItemCartCount invocations
func (mmDecreaseItemCartCount *CheckoutRepoMock) DecreaseItemCartCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecreaseItemCartCount.afterDecreaseItemCartCountCounter)
}

// DecreaseItemCartCountBeforeCounter returns a count of CheckoutRepoMock.DecreaseItemCartCount invocations
func (mmDecreaseItemCartCount *CheckoutRepoMock) DecreaseItemCartCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecreaseItemCartCount.beforeDecreaseItemCartCountCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepoMock.DecreaseItemCartCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDecreaseItemCartCount *mCheckoutRepoMockDecreaseItemCartCount) Calls() []*CheckoutRepoMockDecreaseItemCartCountParams {
	mmDecreaseItemCartCount.mutex.RLock()

	argCopy := make([]*CheckoutRepoMockDecreaseItemCartCountParams, len(mmDecreaseItemCartCount.callArgs))
	copy(argCopy, mmDecreaseItemCartCount.callArgs)

	mmDecreaseItemCartCount.mutex.RUnlock()

	return argCopy
}

// MinimockDecreaseItemCartCountDone returns true if the count of the DecreaseItemCartCount invocations corresponds
// the number of defined expectations
func (m *CheckoutRepoMock) MinimockDecreaseItemCartCountDone() bool {
	for _, e := range m.DecreaseItemCartCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecreaseItemCartCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecreaseItemCartCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecreaseItemCartCount != nil && mm_atomic.LoadUint64(&m.afterDecreaseItemCartCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockDecreaseItemCartCountInspect logs each unmet expectation
func (m *CheckoutRepoMock) MinimockDecreaseItemCartCountInspect() {
	for _, e := range m.DecreaseItemCartCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepoMock.DecreaseItemCartCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecreaseItemCartCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecreaseItemCartCountCounter) < 1 {
		if m.DecreaseItemCartCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepoMock.DecreaseItemCartCount")
		} else {
			m.t.Errorf("Expected call to CheckoutRepoMock.DecreaseItemCartCount with params: %#v", *m.DecreaseItemCartCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecreaseItemCartCount != nil && mm_atomic.LoadUint64(&m.afterDecreaseItemCartCountCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepoMock.DecreaseItemCartCount")
	}
}

type mCheckoutRepoMockDeleteItemCart struct {
	mock               *CheckoutRepoMock
	defaultExpectation *CheckoutRepoMockDeleteItemCartExpectation
	expectations       []*CheckoutRepoMockDeleteItemCartExpectation

	callArgs []*CheckoutRepoMockDeleteItemCartParams
	mutex    sync.RWMutex
}

// CheckoutRepoMockDeleteItemCartExpectation specifies expectation struct of the CheckoutRepo.DeleteItemCart
type CheckoutRepoMockDeleteItemCartExpectation struct {
	mock    *CheckoutRepoMock
	params  *CheckoutRepoMockDeleteItemCartParams
	results *CheckoutRepoMockDeleteItemCartResults
	Counter uint64
}

// CheckoutRepoMockDeleteItemCartParams contains parameters of the CheckoutRepo.DeleteItemCart
type CheckoutRepoMockDeleteItemCartParams struct {
	ctx    context.Context
	userID int64
	sku    uint32
}

// CheckoutRepoMockDeleteItemCartResults contains results of the CheckoutRepo.DeleteItemCart
type CheckoutRepoMockDeleteItemCartResults struct {
	err error
}

// Expect sets up expected params for CheckoutRepo.DeleteItemCart
func (mmDeleteItemCart *mCheckoutRepoMockDeleteItemCart) Expect(ctx context.Context, userID int64, sku uint32) *mCheckoutRepoMockDeleteItemCart {
	if mmDeleteItemCart.mock.funcDeleteItemCart != nil {
		mmDeleteItemCart.mock.t.Fatalf("CheckoutRepoMock.DeleteItemCart mock is already set by Set")
	}

	if mmDeleteItemCart.defaultExpectation == nil {
		mmDeleteItemCart.defaultExpectation = &CheckoutRepoMockDeleteItemCartExpectation{}
	}

	mmDeleteItemCart.defaultExpectation.params = &CheckoutRepoMockDeleteItemCartParams{ctx, userID, sku}
	for _, e := range mmDeleteItemCart.expectations {
		if minimock.Equal(e.params, mmDeleteItemCart.defaultExpectation.params) {
			mmDeleteItemCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemCart.defaultExpectation.params)
		}
	}

	return mmDeleteItemCart
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepo.DeleteItemCart
func (mmDeleteItemCart *mCheckoutRepoMockDeleteItemCart) Inspect(f func(ctx context.Context, userID int64, sku uint32)) *mCheckoutRepoMockDeleteItemCart {
	if mmDeleteItemCart.mock.inspectFuncDeleteItemCart != nil {
		mmDeleteItemCart.mock.t.Fatalf("Inspect function is already set for CheckoutRepoMock.DeleteItemCart")
	}

	mmDeleteItemCart.mock.inspectFuncDeleteItemCart = f

	return mmDeleteItemCart
}

// Return sets up results that will be returned by CheckoutRepo.DeleteItemCart
func (mmDeleteItemCart *mCheckoutRepoMockDeleteItemCart) Return(err error) *CheckoutRepoMock {
	if mmDeleteItemCart.mock.funcDeleteItemCart != nil {
		mmDeleteItemCart.mock.t.Fatalf("CheckoutRepoMock.DeleteItemCart mock is already set by Set")
	}

	if mmDeleteItemCart.defaultExpectation == nil {
		mmDeleteItemCart.defaultExpectation = &CheckoutRepoMockDeleteItemCartExpectation{mock: mmDeleteItemCart.mock}
	}
	mmDeleteItemCart.defaultExpectation.results = &CheckoutRepoMockDeleteItemCartResults{err}
	return mmDeleteItemCart.mock
}

// Set uses given function f to mock the CheckoutRepo.DeleteItemCart method
func (mmDeleteItemCart *mCheckoutRepoMockDeleteItemCart) Set(f func(ctx context.Context, userID int64, sku uint32) (err error)) *CheckoutRepoMock {
	if mmDeleteItemCart.defaultExpectation != nil {
		mmDeleteItemCart.mock.t.Fatalf("Default expectation is already set for the CheckoutRepo.DeleteItemCart method")
	}

	if len(mmDeleteItemCart.expectations) > 0 {
		mmDeleteItemCart.mock.t.Fatalf("Some expectations are already set for the CheckoutRepo.DeleteItemCart method")
	}

	mmDeleteItemCart.mock.funcDeleteItemCart = f
	return mmDeleteItemCart.mock
}

// When sets expectation for the CheckoutRepo.DeleteItemCart which will trigger the result defined by the following
// Then helper
func (mmDeleteItemCart *mCheckoutRepoMockDeleteItemCart) When(ctx context.Context, userID int64, sku uint32) *CheckoutRepoMockDeleteItemCartExpectation {
	if mmDeleteItemCart.mock.funcDeleteItemCart != nil {
		mmDeleteItemCart.mock.t.Fatalf("CheckoutRepoMock.DeleteItemCart mock is already set by Set")
	}

	expectation := &CheckoutRepoMockDeleteItemCartExpectation{
		mock:   mmDeleteItemCart.mock,
		params: &CheckoutRepoMockDeleteItemCartParams{ctx, userID, sku},
	}
	mmDeleteItemCart.expectations = append(mmDeleteItemCart.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepo.DeleteItemCart return parameters for the expectation previously defined by the When method
func (e *CheckoutRepoMockDeleteItemCartExpectation) Then(err error) *CheckoutRepoMock {
	e.results = &CheckoutRepoMockDeleteItemCartResults{err}
	return e.mock
}

// DeleteItemCart implements domain.CheckoutRepo
func (mmDeleteItemCart *CheckoutRepoMock) DeleteItemCart(ctx context.Context, userID int64, sku uint32) (err error) {
	mm_atomic.AddUint64(&mmDeleteItemCart.beforeDeleteItemCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemCart.afterDeleteItemCartCounter, 1)

	if mmDeleteItemCart.inspectFuncDeleteItemCart != nil {
		mmDeleteItemCart.inspectFuncDeleteItemCart(ctx, userID, sku)
	}

	mm_params := &CheckoutRepoMockDeleteItemCartParams{ctx, userID, sku}

	// Record call args
	mmDeleteItemCart.DeleteItemCartMock.mutex.Lock()
	mmDeleteItemCart.DeleteItemCartMock.callArgs = append(mmDeleteItemCart.DeleteItemCartMock.callArgs, mm_params)
	mmDeleteItemCart.DeleteItemCartMock.mutex.Unlock()

	for _, e := range mmDeleteItemCart.DeleteItemCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItemCart.DeleteItemCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemCart.DeleteItemCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemCart.DeleteItemCartMock.defaultExpectation.params
		mm_got := CheckoutRepoMockDeleteItemCartParams{ctx, userID, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemCart.t.Errorf("CheckoutRepoMock.DeleteItemCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemCart.DeleteItemCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemCart.t.Fatal("No results are set for the CheckoutRepoMock.DeleteItemCart")
		}
		return (*mm_results).err
	}
	if mmDeleteItemCart.funcDeleteItemCart != nil {
		return mmDeleteItemCart.funcDeleteItemCart(ctx, userID, sku)
	}
	mmDeleteItemCart.t.Fatalf("Unexpected call to CheckoutRepoMock.DeleteItemCart. %v %v %v", ctx, userID, sku)
	return
}

// DeleteItemCartAfterCounter returns a count of finished CheckoutRepoMock.DeleteItemCart invocations
func (mmDeleteItemCart *CheckoutRepoMock) DeleteItemCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemCart.afterDeleteItemCartCounter)
}

// DeleteItemCartBeforeCounter returns a count of CheckoutRepoMock.DeleteItemCart invocations
func (mmDeleteItemCart *CheckoutRepoMock) DeleteItemCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemCart.beforeDeleteItemCartCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepoMock.DeleteItemCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemCart *mCheckoutRepoMockDeleteItemCart) Calls() []*CheckoutRepoMockDeleteItemCartParams {
	mmDeleteItemCart.mutex.RLock()

	argCopy := make([]*CheckoutRepoMockDeleteItemCartParams, len(mmDeleteItemCart.callArgs))
	copy(argCopy, mmDeleteItemCart.callArgs)

	mmDeleteItemCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemCartDone returns true if the count of the DeleteItemCart invocations corresponds
// the number of defined expectations
func (m *CheckoutRepoMock) MinimockDeleteItemCartDone() bool {
	for _, e := range m.DeleteItemCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemCart != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteItemCartInspect logs each unmet expectation
func (m *CheckoutRepoMock) MinimockDeleteItemCartInspect() {
	for _, e := range m.DeleteItemCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepoMock.DeleteItemCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCartCounter) < 1 {
		if m.DeleteItemCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepoMock.DeleteItemCart")
		} else {
			m.t.Errorf("Expected call to CheckoutRepoMock.DeleteItemCart with params: %#v", *m.DeleteItemCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemCart != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCartCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepoMock.DeleteItemCart")
	}
}

type mCheckoutRepoMockGetCartItems struct {
	mock               *CheckoutRepoMock
	defaultExpectation *CheckoutRepoMockGetCartItemsExpectation
	expectations       []*CheckoutRepoMockGetCartItemsExpectation

	callArgs []*CheckoutRepoMockGetCartItemsParams
	mutex    sync.RWMutex
}

// CheckoutRepoMockGetCartItemsExpectation specifies expectation struct of the CheckoutRepo.GetCartItems
type CheckoutRepoMockGetCartItemsExpectation struct {
	mock    *CheckoutRepoMock
	params  *CheckoutRepoMockGetCartItemsParams
	results *CheckoutRepoMockGetCartItemsResults
	Counter uint64
}

// CheckoutRepoMockGetCartItemsParams contains parameters of the CheckoutRepo.GetCartItems
type CheckoutRepoMockGetCartItemsParams struct {
	ctx    context.Context
	userID int64
}

// CheckoutRepoMockGetCartItemsResults contains results of the CheckoutRepo.GetCartItems
type CheckoutRepoMockGetCartItemsResults struct {
	ia1 []model.Item
	err error
}

// Expect sets up expected params for CheckoutRepo.GetCartItems
func (mmGetCartItems *mCheckoutRepoMockGetCartItems) Expect(ctx context.Context, userID int64) *mCheckoutRepoMockGetCartItems {
	if mmGetCartItems.mock.funcGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("CheckoutRepoMock.GetCartItems mock is already set by Set")
	}

	if mmGetCartItems.defaultExpectation == nil {
		mmGetCartItems.defaultExpectation = &CheckoutRepoMockGetCartItemsExpectation{}
	}

	mmGetCartItems.defaultExpectation.params = &CheckoutRepoMockGetCartItemsParams{ctx, userID}
	for _, e := range mmGetCartItems.expectations {
		if minimock.Equal(e.params, mmGetCartItems.defaultExpectation.params) {
			mmGetCartItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItems.defaultExpectation.params)
		}
	}

	return mmGetCartItems
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepo.GetCartItems
func (mmGetCartItems *mCheckoutRepoMockGetCartItems) Inspect(f func(ctx context.Context, userID int64)) *mCheckoutRepoMockGetCartItems {
	if mmGetCartItems.mock.inspectFuncGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("Inspect function is already set for CheckoutRepoMock.GetCartItems")
	}

	mmGetCartItems.mock.inspectFuncGetCartItems = f

	return mmGetCartItems
}

// Return sets up results that will be returned by CheckoutRepo.GetCartItems
func (mmGetCartItems *mCheckoutRepoMockGetCartItems) Return(ia1 []model.Item, err error) *CheckoutRepoMock {
	if mmGetCartItems.mock.funcGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("CheckoutRepoMock.GetCartItems mock is already set by Set")
	}

	if mmGetCartItems.defaultExpectation == nil {
		mmGetCartItems.defaultExpectation = &CheckoutRepoMockGetCartItemsExpectation{mock: mmGetCartItems.mock}
	}
	mmGetCartItems.defaultExpectation.results = &CheckoutRepoMockGetCartItemsResults{ia1, err}
	return mmGetCartItems.mock
}

// Set uses given function f to mock the CheckoutRepo.GetCartItems method
func (mmGetCartItems *mCheckoutRepoMockGetCartItems) Set(f func(ctx context.Context, userID int64) (ia1 []model.Item, err error)) *CheckoutRepoMock {
	if mmGetCartItems.defaultExpectation != nil {
		mmGetCartItems.mock.t.Fatalf("Default expectation is already set for the CheckoutRepo.GetCartItems method")
	}

	if len(mmGetCartItems.expectations) > 0 {
		mmGetCartItems.mock.t.Fatalf("Some expectations are already set for the CheckoutRepo.GetCartItems method")
	}

	mmGetCartItems.mock.funcGetCartItems = f
	return mmGetCartItems.mock
}

// When sets expectation for the CheckoutRepo.GetCartItems which will trigger the result defined by the following
// Then helper
func (mmGetCartItems *mCheckoutRepoMockGetCartItems) When(ctx context.Context, userID int64) *CheckoutRepoMockGetCartItemsExpectation {
	if mmGetCartItems.mock.funcGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("CheckoutRepoMock.GetCartItems mock is already set by Set")
	}

	expectation := &CheckoutRepoMockGetCartItemsExpectation{
		mock:   mmGetCartItems.mock,
		params: &CheckoutRepoMockGetCartItemsParams{ctx, userID},
	}
	mmGetCartItems.expectations = append(mmGetCartItems.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepo.GetCartItems return parameters for the expectation previously defined by the When method
func (e *CheckoutRepoMockGetCartItemsExpectation) Then(ia1 []model.Item, err error) *CheckoutRepoMock {
	e.results = &CheckoutRepoMockGetCartItemsResults{ia1, err}
	return e.mock
}

// GetCartItems implements domain.CheckoutRepo
func (mmGetCartItems *CheckoutRepoMock) GetCartItems(ctx context.Context, userID int64) (ia1 []model.Item, err error) {
	mm_atomic.AddUint64(&mmGetCartItems.beforeGetCartItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItems.afterGetCartItemsCounter, 1)

	if mmGetCartItems.inspectFuncGetCartItems != nil {
		mmGetCartItems.inspectFuncGetCartItems(ctx, userID)
	}

	mm_params := &CheckoutRepoMockGetCartItemsParams{ctx, userID}

	// Record call args
	mmGetCartItems.GetCartItemsMock.mutex.Lock()
	mmGetCartItems.GetCartItemsMock.callArgs = append(mmGetCartItems.GetCartItemsMock.callArgs, mm_params)
	mmGetCartItems.GetCartItemsMock.mutex.Unlock()

	for _, e := range mmGetCartItems.GetCartItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetCartItems.GetCartItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItems.GetCartItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItems.GetCartItemsMock.defaultExpectation.params
		mm_got := CheckoutRepoMockGetCartItemsParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItems.t.Errorf("CheckoutRepoMock.GetCartItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItems.GetCartItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItems.t.Fatal("No results are set for the CheckoutRepoMock.GetCartItems")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetCartItems.funcGetCartItems != nil {
		return mmGetCartItems.funcGetCartItems(ctx, userID)
	}
	mmGetCartItems.t.Fatalf("Unexpected call to CheckoutRepoMock.GetCartItems. %v %v", ctx, userID)
	return
}

// GetCartItemsAfterCounter returns a count of finished CheckoutRepoMock.GetCartItems invocations
func (mmGetCartItems *CheckoutRepoMock) GetCartItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItems.afterGetCartItemsCounter)
}

// GetCartItemsBeforeCounter returns a count of CheckoutRepoMock.GetCartItems invocations
func (mmGetCartItems *CheckoutRepoMock) GetCartItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItems.beforeGetCartItemsCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepoMock.GetCartItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItems *mCheckoutRepoMockGetCartItems) Calls() []*CheckoutRepoMockGetCartItemsParams {
	mmGetCartItems.mutex.RLock()

	argCopy := make([]*CheckoutRepoMockGetCartItemsParams, len(mmGetCartItems.callArgs))
	copy(argCopy, mmGetCartItems.callArgs)

	mmGetCartItems.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemsDone returns true if the count of the GetCartItems invocations corresponds
// the number of defined expectations
func (m *CheckoutRepoMock) MinimockGetCartItemsDone() bool {
	for _, e := range m.GetCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItems != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartItemsInspect logs each unmet expectation
func (m *CheckoutRepoMock) MinimockGetCartItemsInspect() {
	for _, e := range m.GetCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepoMock.GetCartItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		if m.GetCartItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepoMock.GetCartItems")
		} else {
			m.t.Errorf("Expected call to CheckoutRepoMock.GetCartItems with params: %#v", *m.GetCartItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItems != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepoMock.GetCartItems")
	}
}

type mCheckoutRepoMockGetItemCartCount struct {
	mock               *CheckoutRepoMock
	defaultExpectation *CheckoutRepoMockGetItemCartCountExpectation
	expectations       []*CheckoutRepoMockGetItemCartCountExpectation

	callArgs []*CheckoutRepoMockGetItemCartCountParams
	mutex    sync.RWMutex
}

// CheckoutRepoMockGetItemCartCountExpectation specifies expectation struct of the CheckoutRepo.GetItemCartCount
type CheckoutRepoMockGetItemCartCountExpectation struct {
	mock    *CheckoutRepoMock
	params  *CheckoutRepoMockGetItemCartCountParams
	results *CheckoutRepoMockGetItemCartCountResults
	Counter uint64
}

// CheckoutRepoMockGetItemCartCountParams contains parameters of the CheckoutRepo.GetItemCartCount
type CheckoutRepoMockGetItemCartCountParams struct {
	ctx       context.Context
	userID    int64
	modelItem model.Item
}

// CheckoutRepoMockGetItemCartCountResults contains results of the CheckoutRepo.GetItemCartCount
type CheckoutRepoMockGetItemCartCountResults struct {
	i1  int32
	err error
}

// Expect sets up expected params for CheckoutRepo.GetItemCartCount
func (mmGetItemCartCount *mCheckoutRepoMockGetItemCartCount) Expect(ctx context.Context, userID int64, modelItem model.Item) *mCheckoutRepoMockGetItemCartCount {
	if mmGetItemCartCount.mock.funcGetItemCartCount != nil {
		mmGetItemCartCount.mock.t.Fatalf("CheckoutRepoMock.GetItemCartCount mock is already set by Set")
	}

	if mmGetItemCartCount.defaultExpectation == nil {
		mmGetItemCartCount.defaultExpectation = &CheckoutRepoMockGetItemCartCountExpectation{}
	}

	mmGetItemCartCount.defaultExpectation.params = &CheckoutRepoMockGetItemCartCountParams{ctx, userID, modelItem}
	for _, e := range mmGetItemCartCount.expectations {
		if minimock.Equal(e.params, mmGetItemCartCount.defaultExpectation.params) {
			mmGetItemCartCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemCartCount.defaultExpectation.params)
		}
	}

	return mmGetItemCartCount
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepo.GetItemCartCount
func (mmGetItemCartCount *mCheckoutRepoMockGetItemCartCount) Inspect(f func(ctx context.Context, userID int64, modelItem model.Item)) *mCheckoutRepoMockGetItemCartCount {
	if mmGetItemCartCount.mock.inspectFuncGetItemCartCount != nil {
		mmGetItemCartCount.mock.t.Fatalf("Inspect function is already set for CheckoutRepoMock.GetItemCartCount")
	}

	mmGetItemCartCount.mock.inspectFuncGetItemCartCount = f

	return mmGetItemCartCount
}

// Return sets up results that will be returned by CheckoutRepo.GetItemCartCount
func (mmGetItemCartCount *mCheckoutRepoMockGetItemCartCount) Return(i1 int32, err error) *CheckoutRepoMock {
	if mmGetItemCartCount.mock.funcGetItemCartCount != nil {
		mmGetItemCartCount.mock.t.Fatalf("CheckoutRepoMock.GetItemCartCount mock is already set by Set")
	}

	if mmGetItemCartCount.defaultExpectation == nil {
		mmGetItemCartCount.defaultExpectation = &CheckoutRepoMockGetItemCartCountExpectation{mock: mmGetItemCartCount.mock}
	}
	mmGetItemCartCount.defaultExpectation.results = &CheckoutRepoMockGetItemCartCountResults{i1, err}
	return mmGetItemCartCount.mock
}

// Set uses given function f to mock the CheckoutRepo.GetItemCartCount method
func (mmGetItemCartCount *mCheckoutRepoMockGetItemCartCount) Set(f func(ctx context.Context, userID int64, modelItem model.Item) (i1 int32, err error)) *CheckoutRepoMock {
	if mmGetItemCartCount.defaultExpectation != nil {
		mmGetItemCartCount.mock.t.Fatalf("Default expectation is already set for the CheckoutRepo.GetItemCartCount method")
	}

	if len(mmGetItemCartCount.expectations) > 0 {
		mmGetItemCartCount.mock.t.Fatalf("Some expectations are already set for the CheckoutRepo.GetItemCartCount method")
	}

	mmGetItemCartCount.mock.funcGetItemCartCount = f
	return mmGetItemCartCount.mock
}

// When sets expectation for the CheckoutRepo.GetItemCartCount which will trigger the result defined by the following
// Then helper
func (mmGetItemCartCount *mCheckoutRepoMockGetItemCartCount) When(ctx context.Context, userID int64, modelItem model.Item) *CheckoutRepoMockGetItemCartCountExpectation {
	if mmGetItemCartCount.mock.funcGetItemCartCount != nil {
		mmGetItemCartCount.mock.t.Fatalf("CheckoutRepoMock.GetItemCartCount mock is already set by Set")
	}

	expectation := &CheckoutRepoMockGetItemCartCountExpectation{
		mock:   mmGetItemCartCount.mock,
		params: &CheckoutRepoMockGetItemCartCountParams{ctx, userID, modelItem},
	}
	mmGetItemCartCount.expectations = append(mmGetItemCartCount.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepo.GetItemCartCount return parameters for the expectation previously defined by the When method
func (e *CheckoutRepoMockGetItemCartCountExpectation) Then(i1 int32, err error) *CheckoutRepoMock {
	e.results = &CheckoutRepoMockGetItemCartCountResults{i1, err}
	return e.mock
}

// GetItemCartCount implements domain.CheckoutRepo
func (mmGetItemCartCount *CheckoutRepoMock) GetItemCartCount(ctx context.Context, userID int64, modelItem model.Item) (i1 int32, err error) {
	mm_atomic.AddUint64(&mmGetItemCartCount.beforeGetItemCartCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemCartCount.afterGetItemCartCountCounter, 1)

	if mmGetItemCartCount.inspectFuncGetItemCartCount != nil {
		mmGetItemCartCount.inspectFuncGetItemCartCount(ctx, userID, modelItem)
	}

	mm_params := &CheckoutRepoMockGetItemCartCountParams{ctx, userID, modelItem}

	// Record call args
	mmGetItemCartCount.GetItemCartCountMock.mutex.Lock()
	mmGetItemCartCount.GetItemCartCountMock.callArgs = append(mmGetItemCartCount.GetItemCartCountMock.callArgs, mm_params)
	mmGetItemCartCount.GetItemCartCountMock.mutex.Unlock()

	for _, e := range mmGetItemCartCount.GetItemCartCountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetItemCartCount.GetItemCartCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemCartCount.GetItemCartCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemCartCount.GetItemCartCountMock.defaultExpectation.params
		mm_got := CheckoutRepoMockGetItemCartCountParams{ctx, userID, modelItem}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemCartCount.t.Errorf("CheckoutRepoMock.GetItemCartCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemCartCount.GetItemCartCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemCartCount.t.Fatal("No results are set for the CheckoutRepoMock.GetItemCartCount")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetItemCartCount.funcGetItemCartCount != nil {
		return mmGetItemCartCount.funcGetItemCartCount(ctx, userID, modelItem)
	}
	mmGetItemCartCount.t.Fatalf("Unexpected call to CheckoutRepoMock.GetItemCartCount. %v %v %v", ctx, userID, modelItem)
	return
}

// GetItemCartCountAfterCounter returns a count of finished CheckoutRepoMock.GetItemCartCount invocations
func (mmGetItemCartCount *CheckoutRepoMock) GetItemCartCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemCartCount.afterGetItemCartCountCounter)
}

// GetItemCartCountBeforeCounter returns a count of CheckoutRepoMock.GetItemCartCount invocations
func (mmGetItemCartCount *CheckoutRepoMock) GetItemCartCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemCartCount.beforeGetItemCartCountCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepoMock.GetItemCartCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemCartCount *mCheckoutRepoMockGetItemCartCount) Calls() []*CheckoutRepoMockGetItemCartCountParams {
	mmGetItemCartCount.mutex.RLock()

	argCopy := make([]*CheckoutRepoMockGetItemCartCountParams, len(mmGetItemCartCount.callArgs))
	copy(argCopy, mmGetItemCartCount.callArgs)

	mmGetItemCartCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemCartCountDone returns true if the count of the GetItemCartCount invocations corresponds
// the number of defined expectations
func (m *CheckoutRepoMock) MinimockGetItemCartCountDone() bool {
	for _, e := range m.GetItemCartCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemCartCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemCartCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemCartCount != nil && mm_atomic.LoadUint64(&m.afterGetItemCartCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetItemCartCountInspect logs each unmet expectation
func (m *CheckoutRepoMock) MinimockGetItemCartCountInspect() {
	for _, e := range m.GetItemCartCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepoMock.GetItemCartCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemCartCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemCartCountCounter) < 1 {
		if m.GetItemCartCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepoMock.GetItemCartCount")
		} else {
			m.t.Errorf("Expected call to CheckoutRepoMock.GetItemCartCount with params: %#v", *m.GetItemCartCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemCartCount != nil && mm_atomic.LoadUint64(&m.afterGetItemCartCountCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepoMock.GetItemCartCount")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CheckoutRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToCartInspect()

		m.MinimockClearCartInspect()

		m.MinimockDecreaseItemCartCountInspect()

		m.MinimockDeleteItemCartInspect()

		m.MinimockGetCartItemsInspect()

		m.MinimockGetItemCartCountInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CheckoutRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CheckoutRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockClearCartDone() &&
		m.MinimockDecreaseItemCartCountDone() &&
		m.MinimockDeleteItemCartDone() &&
		m.MinimockGetCartItemsDone() &&
		m.MinimockGetItemCartCountDone()
}
